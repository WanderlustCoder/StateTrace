#Requires -Version 5.1
Set-StrictMode -Version Latest

<#
.SYNOPSIS
    Network documentation generator module for StateTrace.

.DESCRIPTION
    Provides comprehensive document generation capabilities including template
    engine, as-built documentation, multi-format export, and scheduled generation.

.NOTES
    Plan AA - Network Documentation Generator
#>

# Module-level databases
$script:DocumentTemplates = $null
$script:GeneratedDocuments = $null
$script:DocumentSchedules = $null
$script:DocumentHistory = $null
$script:DatabasePath = $null

#region Initialization

function Initialize-DocumentationDatabase {
    <#
    .SYNOPSIS
        Initializes the documentation generator database structures.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$Path,

        [Parameter()]
        [switch]$TestMode
    )

    if ($TestMode) {
        $script:DatabasePath = $null
    } elseif ($Path) {
        $script:DatabasePath = $Path
    } else {
        $dataDir = Join-Path $PSScriptRoot '..\Data'
        if (-not (Test-Path $dataDir)) {
            New-Item -ItemType Directory -Path $dataDir -Force | Out-Null
        }
        $script:DatabasePath = Join-Path $dataDir 'DocumentationDatabase.json'
    }

    # Initialize empty databases
    $script:DocumentTemplates = New-Object System.Collections.ArrayList
    $script:GeneratedDocuments = New-Object System.Collections.ArrayList
    $script:DocumentSchedules = New-Object System.Collections.ArrayList
    $script:DocumentHistory = New-Object System.Collections.ArrayList

    # Load existing data if available
    if ($script:DatabasePath -and (Test-Path $script:DatabasePath)) {
        Import-DocumentationDatabase -Path $script:DatabasePath
    }

    # Load built-in templates
    Initialize-BuiltInTemplates
}

function Initialize-BuiltInTemplates {
    <#
    .SYNOPSIS
        Loads built-in document templates.
    #>
    $builtInTemplates = @(
        @{
            TemplateID = 'Site-AsBuilt'
            Name = 'Site As-Built Document'
            Description = 'Comprehensive site documentation with device inventory and VLAN summary'
            Category = 'As-Built'
            Variables = @('site_name', 'site_location', 'generated_date', 'devices', 'vlans', 'subnets')
            Content = @'
# {{site_name}} Network Documentation

**Generated:** {{generated_date}}
**Location:** {{site_location}}

---

## Table of Contents
1. [Executive Summary](#executive-summary)
2. [Device Inventory](#device-inventory)
3. [VLAN Summary](#vlan-summary)
4. [IP Addressing](#ip-addressing)

---

## Executive Summary

This document provides comprehensive network documentation for the {{site_name}} site.

**Key Statistics:**
- Total Devices: {{device_count}}
- Total Ports: {{port_count}}
- Active VLANs: {{vlan_count}}

---

## Device Inventory

| Hostname | Vendor | Model | Role | Location | Ports |
|----------|--------|-------|------|----------|-------|
{{#each devices}}
| {{hostname}} | {{vendor}} | {{model}} | {{role}} | {{location}} | {{port_count}} |
{{/each}}

---

## VLAN Summary

| ID | Name | Purpose | Subnet | Gateway |
|----|------|---------|--------|---------|
{{#each vlans}}
| {{id}} | {{name}} | {{purpose}} | {{subnet}} | {{gateway}} |
{{/each}}

---

## IP Addressing

{{#each subnets}}
### {{name}} ({{cidr}})
- **Network:** {{network}}
- **Gateway:** {{gateway}}
- **Usable Range:** {{first_usable}} - {{last_usable}}
- **Broadcast:** {{broadcast}}

{{/each}}

---

*Document generated by StateTrace Documentation Generator*
'@
        }
        @{
            TemplateID = 'Device-Summary'
            Name = 'Device Summary'
            Description = 'Single device documentation with interface inventory'
            Category = 'Device'
            Variables = @('hostname', 'vendor', 'model', 'serial', 'firmware', 'interfaces', 'generated_date')
            Content = @'
# {{hostname}} Device Documentation

**Generated:** {{generated_date}}

---

## Device Information

| Property | Value |
|----------|-------|
| Hostname | {{hostname}} |
| Vendor | {{vendor}} |
| Model | {{model}} |
| Serial Number | {{serial}} |
| Firmware Version | {{firmware}} |
| Management IP | {{management_ip}} |
| Location | {{location}} |

---

## Interface Inventory

| Port | Description | VLAN | Status | Speed | Connected Device |
|------|-------------|------|--------|-------|------------------|
{{#each interfaces}}
| {{name}} | {{description}} | {{vlan}} | {{status}} | {{speed}} | {{connected_to}} |
{{/each}}

---

## Port Utilization

- **Total Ports:** {{total_ports}}
- **Connected:** {{connected_ports}}
- **Available:** {{available_ports}}
- **Utilization:** {{utilization_percent}}%

---

*Document generated by StateTrace Documentation Generator*
'@
        }
        @{
            TemplateID = 'VLAN-Reference'
            Name = 'VLAN Reference Guide'
            Description = 'VLAN inventory with usage details'
            Category = 'Reference'
            Variables = @('site_name', 'vlans', 'generated_date')
            Content = @'
# {{site_name}} VLAN Reference Guide

**Generated:** {{generated_date}}

---

## VLAN Overview

| ID | Name | Type | Subnet | Ports Using |
|----|------|------|--------|-------------|
{{#each vlans}}
| {{id}} | {{name}} | {{type}} | {{subnet}} | {{port_count}} |
{{/each}}

---

## VLAN Details

{{#each vlans}}
### VLAN {{id}} - {{name}}

- **Purpose:** {{purpose}}
- **Subnet:** {{subnet}}
- **Gateway:** {{gateway}}
- **DHCP Scope:** {{dhcp_scope}}
- **Ports Assigned:** {{port_count}}

{{#if has_voice}}
**Voice VLAN Configuration:**
- Voice VLAN enabled on {{voice_port_count}} ports
{{/if}}

{{/each}}

---

*Document generated by StateTrace Documentation Generator*
'@
        }
        @{
            TemplateID = 'IP-Allocation'
            Name = 'IP Address Allocation'
            Description = 'IP addressing scheme documentation'
            Category = 'Reference'
            Variables = @('site_name', 'subnets', 'reserved_addresses', 'generated_date')
            Content = @'
# {{site_name}} IP Address Allocation

**Generated:** {{generated_date}}

---

## Subnet Allocation

| Subnet | CIDR | VLAN | Purpose | Utilization |
|--------|------|------|---------|-------------|
{{#each subnets}}
| {{network}} | {{cidr}} | {{vlan_id}} | {{purpose}} | {{utilization}}% |
{{/each}}

---

## Reserved Addresses

| IP Address | Hostname | Purpose |
|------------|----------|---------|
{{#each reserved_addresses}}
| {{ip}} | {{hostname}} | {{purpose}} |
{{/each}}

---

*Document generated by StateTrace Documentation Generator*
'@
        }
        @{
            TemplateID = 'Executive-Summary'
            Name = 'Executive Summary Report'
            Description = 'High-level network summary for management'
            Category = 'Report'
            Variables = @('report_title', 'period', 'site_count', 'device_count', 'highlights', 'recommendations', 'generated_date')
            Content = @'
# {{report_title}}

**Report Period:** {{period}}
**Generated:** {{generated_date}}

---

## Overview

This executive summary provides a high-level view of the network infrastructure.

### Key Metrics

| Metric | Value |
|--------|-------|
| Total Sites | {{site_count}} |
| Total Devices | {{device_count}} |
| Total Ports | {{port_count}} |
| Port Utilization | {{port_utilization}}% |

---

## Highlights

{{#each highlights}}
- {{this}}
{{/each}}

---

## Recommendations

{{#each recommendations}}
{{@index}}. {{this}}
{{/each}}

---

*Report generated by StateTrace Documentation Generator*
'@
        }
        @{
            TemplateID = 'Change-Summary'
            Name = 'Change Summary Report'
            Description = 'Summary of recent network changes'
            Category = 'Report'
            Variables = @('site_name', 'period', 'changes', 'generated_date')
            Content = @'
# {{site_name}} Change Summary

**Period:** {{period}}
**Generated:** {{generated_date}}

---

## Changes Overview

| Date | Change ID | Type | Description | Status |
|------|-----------|------|-------------|--------|
{{#each changes}}
| {{date}} | {{change_id}} | {{type}} | {{description}} | {{status}} |
{{/each}}

---

## Change Statistics

- **Total Changes:** {{total_changes}}
- **Completed:** {{completed_changes}}
- **Success Rate:** {{success_rate}}%

---

*Report generated by StateTrace Documentation Generator*
'@
        }
        @{
            TemplateID = 'Cable-Matrix'
            Name = 'Cable Matrix'
            Description = 'Cable and port connection documentation'
            Category = 'Physical'
            Variables = @('site_name', 'cables', 'patch_panels', 'generated_date')
            Content = @'
# {{site_name}} Cable Matrix

**Generated:** {{generated_date}}

---

## Cable Run Summary

| Cable ID | From | To | Type | Length | Status |
|----------|------|-----|------|--------|--------|
{{#each cables}}
| {{cable_id}} | {{from_location}} | {{to_location}} | {{cable_type}} | {{length}} | {{status}} |
{{/each}}

---

## Patch Panel Assignments

{{#each patch_panels}}
### {{name}} ({{location}})

| Port | Label | Connected To | Notes |
|------|-------|--------------|-------|
{{#each ports}}
| {{number}} | {{label}} | {{connected_to}} | {{notes}} |
{{/each}}

{{/each}}

---

*Document generated by StateTrace Documentation Generator*
'@
        }
    )

    foreach ($template in $builtInTemplates) {
        $existing = $script:DocumentTemplates | Where-Object { $_.TemplateID -eq $template.TemplateID }
        if (-not $existing) {
            $template['IsBuiltIn'] = $true
            $template['CreatedDate'] = Get-Date
            $template['ModifiedDate'] = Get-Date
            $template['Version'] = '1.0'
            $templateObj = [PSCustomObject]$template
            [void]$script:DocumentTemplates.Add($templateObj)
        }
    }
}

#endregion

#region Template Engine

function Expand-DocumentTemplate {
    <#
    .SYNOPSIS
        Expands a template with variable substitution, conditionals, and loops.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Template,

        [Parameter()]
        [hashtable]$Variables = @{}
    )

    $result = $Template

    # Process {{#each}} loops first
    $eachPattern = '{{#each\s+(\w+)}}([\s\S]*?){{/each}}'
    while ($result -match $eachPattern) {
        $fullMatch = $Matches[0]
        $varName = $Matches[1]
        $loopContent = $Matches[2]

        $loopResult = ''
        if ($Variables.ContainsKey($varName) -and $Variables[$varName]) {
            $items = @($Variables[$varName])
            $index = 0
            foreach ($item in $items) {
                $itemContent = $loopContent
                # Replace {{@index}} with current index
                $itemContent = $itemContent -replace '{{@index}}', ($index + 1)
                # Replace {{this}} with the item itself (for simple arrays)
                if ($item -is [string] -or $item -is [int]) {
                    $itemContent = $itemContent -replace '{{this}}', $item
                }
                # Replace item properties
                if ($item -is [hashtable]) {
                    foreach ($key in $item.Keys) {
                        $itemContent = $itemContent -replace "{{$key}}", $item[$key]
                    }
                } elseif ($item.PSObject.Properties) {
                    foreach ($prop in $item.PSObject.Properties) {
                        $itemContent = $itemContent -replace "{{$($prop.Name)}}", $prop.Value
                    }
                }
                $loopResult += $itemContent
                $index++
            }
        }
        $result = $result.Replace($fullMatch, $loopResult)
    }

    # Process {{#if}} conditionals
    $ifElsePattern = '{{#if\s+(\w+)}}([\s\S]*?){{else}}([\s\S]*?){{/if}}'
    while ($result -match $ifElsePattern) {
        $fullMatch = $Matches[0]
        $varName = $Matches[1]
        $trueContent = $Matches[2]
        $falseContent = $Matches[3]

        $conditionValue = $false
        if ($Variables.ContainsKey($varName)) {
            $val = $Variables[$varName]
            $conditionValue = $val -and $val -ne $false -and $val -ne 0 -and $val -ne ''
        }

        $replacement = if ($conditionValue) { $trueContent } else { $falseContent }
        $result = $result.Replace($fullMatch, $replacement)
    }

    # Process {{#if}} without else
    $ifPattern = '{{#if\s+(\w+)}}([\s\S]*?){{/if}}'
    while ($result -match $ifPattern) {
        $fullMatch = $Matches[0]
        $varName = $Matches[1]
        $trueContent = $Matches[2]

        $conditionValue = $false
        if ($Variables.ContainsKey($varName)) {
            $val = $Variables[$varName]
            $conditionValue = $val -and $val -ne $false -and $val -ne 0 -and $val -ne ''
        }

        $replacement = if ($conditionValue) { $trueContent } else { '' }
        $result = $result.Replace($fullMatch, $replacement)
    }

    # Process simple variable substitution {{variable}}
    $varPattern = '{{(\w+)}}'
    $result = [regex]::Replace($result, $varPattern, {
        param($match)
        $varName = $match.Groups[1].Value
        if ($Variables.ContainsKey($varName)) {
            return $Variables[$varName]
        }
        return "N/A"
    })

    return $result
}

#endregion

#region Template Management

function Get-DocumentTemplate {
    <#
    .SYNOPSIS
        Retrieves document templates.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$TemplateID,

        [Parameter()]
        [string]$Name,

        [Parameter()]
        [string]$Category
    )

    $templates = $script:DocumentTemplates

    if ($TemplateID) {
        $templates = $templates | Where-Object { $_.TemplateID -eq $TemplateID }
    }

    if ($Name) {
        $templates = $templates | Where-Object { $_.Name -like "*$Name*" }
    }

    if ($Category) {
        $templates = $templates | Where-Object { $_.Category -eq $Category }
    }

    return $templates
}

function New-DocumentTemplate {
    <#
    .SYNOPSIS
        Creates a new document template.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Name,

        [Parameter(Mandatory)]
        [string]$Content,

        [Parameter()]
        [string]$Description,

        [Parameter()]
        [string]$Category = 'Custom',

        [Parameter()]
        [string[]]$Variables
    )

    # Generate template ID
    $dateStr = (Get-Date).ToString('yyyyMMdd')
    $existing = @($script:DocumentTemplates | Where-Object { $_.TemplateID -like "CUSTOM-$dateStr-*" })
    $sequence = ($existing.Count + 1).ToString('0000')
    $templateId = "CUSTOM-$dateStr-$sequence"

    $template = [PSCustomObject]@{
        TemplateID = $templateId
        Name = $Name
        Description = $Description
        Category = $Category
        Content = $Content
        Variables = $Variables
        IsBuiltIn = $false
        CreatedDate = Get-Date
        ModifiedDate = Get-Date
        Version = '1.0'
        Author = $env:USERNAME
    }

    [void]$script:DocumentTemplates.Add($template)

    return $template
}

function Update-DocumentTemplate {
    <#
    .SYNOPSIS
        Updates an existing document template.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$TemplateID,

        [Parameter()]
        [string]$Name,

        [Parameter()]
        [string]$Content,

        [Parameter()]
        [string]$Description,

        [Parameter()]
        [string[]]$Variables
    )

    $template = $script:DocumentTemplates | Where-Object { $_.TemplateID -eq $TemplateID }
    if (-not $template) {
        throw "Template '$TemplateID' not found"
    }

    if ($template.IsBuiltIn) {
        throw "Cannot modify built-in templates"
    }

    if ($Name) { $template.Name = $Name }
    if ($Content) { $template.Content = $Content }
    if ($Description) { $template.Description = $Description }
    if ($Variables) { $template.Variables = $Variables }

    $template.ModifiedDate = Get-Date
    # Increment version
    $version = [Version]$template.Version
    $template.Version = "$($version.Major).$($version.Minor + 1)"

    return $template
}

function Remove-DocumentTemplate {
    <#
    .SYNOPSIS
        Removes a document template.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$TemplateID
    )

    $template = $script:DocumentTemplates | Where-Object { $_.TemplateID -eq $TemplateID }
    if (-not $template) {
        throw "Template '$TemplateID' not found"
    }

    if ($template.IsBuiltIn) {
        throw "Cannot remove built-in templates"
    }

    [void]$script:DocumentTemplates.Remove($template)
}

function Test-DocumentTemplate {
    <#
    .SYNOPSIS
        Validates a document template syntax.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Content
    )

    $errors = @()

    # Check for unmatched {{#each}}
    $eachOpens = ([regex]::Matches($Content, '{{#each\s+\w+}}')).Count
    $eachCloses = ([regex]::Matches($Content, '{{/each}}')).Count
    if ($eachOpens -ne $eachCloses) {
        $errors += "Unmatched {{#each}} blocks: $eachOpens opens, $eachCloses closes"
    }

    # Check for unmatched {{#if}}
    $ifOpens = ([regex]::Matches($Content, '{{#if\s+\w+}}')).Count
    $ifCloses = ([regex]::Matches($Content, '{{/if}}')).Count
    if ($ifOpens -ne $ifCloses) {
        $errors += "Unmatched {{#if}} blocks: $ifOpens opens, $ifCloses closes"
    }

    # Extract variables used
    $variableMatches = [regex]::Matches($Content, '{{(\w+)}}')
    $variables = @($variableMatches | ForEach-Object { $_.Groups[1].Value } | Select-Object -Unique)

    return [PSCustomObject]@{
        IsValid = $errors.Count -eq 0
        Errors = $errors
        Variables = $variables
    }
}

#endregion

#region Document Generation

function New-Document {
    <#
    .SYNOPSIS
        Generates a new document from a template.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$TemplateID,

        [Parameter(Mandatory)]
        [string]$Title,

        [Parameter()]
        [hashtable]$Variables = @{},

        [Parameter()]
        [string]$Scope
    )

    $template = Get-DocumentTemplate -TemplateID $TemplateID
    if (-not $template) {
        throw "Template '$TemplateID' not found"
    }

    # Add default variables
    $allVariables = @{
        generated_date = (Get-Date).ToString('yyyy-MM-dd HH:mm:ss')
        generated_by = $env:USERNAME
    }
    foreach ($key in $Variables.Keys) {
        $allVariables[$key] = $Variables[$key]
    }

    # Expand template
    $content = Expand-DocumentTemplate -Template $template.Content -Variables $allVariables

    # Generate document ID
    $dateStr = (Get-Date).ToString('yyyyMMdd')
    $existing = @($script:GeneratedDocuments | Where-Object { $_.DocumentID -like "DOC-$dateStr-*" })
    $sequence = ($existing.Count + 1).ToString('0000')
    $documentId = "DOC-$dateStr-$sequence"

    $document = [PSCustomObject]@{
        DocumentID = $documentId
        TemplateID = $TemplateID
        Title = $Title
        Content = $content
        Scope = $Scope
        Variables = $allVariables
        GeneratedDate = Get-Date
        GeneratedBy = $env:USERNAME
        Format = 'Markdown'
        Sections = @(Get-DocumentSections -Content $content)
    }

    [void]$script:GeneratedDocuments.Add($document)

    # Log history
    $null = Add-DocumentHistoryEntry -DocumentID $documentId -Action 'Generated' -Details "Generated from template $TemplateID"

    return $document
}

function Get-DocumentSections {
    <#
    .SYNOPSIS
        Extracts section headings from document content.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Content
    )

    $sections = @()
    $headingPattern = '^#{1,3}\s+(.+)$'

    foreach ($line in $Content -split "`n") {
        if ($line -match $headingPattern) {
            $sections += $Matches[1].Trim()
        }
    }

    return $sections
}

function Get-GeneratedDocument {
    <#
    .SYNOPSIS
        Retrieves generated documents.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$DocumentID,

        [Parameter()]
        [string]$TemplateID,

        [Parameter()]
        [string]$Scope
    )

    $documents = $script:GeneratedDocuments

    if ($DocumentID) {
        $documents = $documents | Where-Object { $_.DocumentID -eq $DocumentID }
    }

    if ($TemplateID) {
        $documents = $documents | Where-Object { $_.TemplateID -eq $TemplateID }
    }

    if ($Scope) {
        $documents = $documents | Where-Object { $_.Scope -eq $Scope }
    }

    return $documents | Sort-Object GeneratedDate -Descending
}

function Remove-GeneratedDocument {
    <#
    .SYNOPSIS
        Removes a generated document.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$DocumentID
    )

    $document = $script:GeneratedDocuments | Where-Object { $_.DocumentID -eq $DocumentID }
    if (-not $document) {
        throw "Document '$DocumentID' not found"
    }

    [void]$script:GeneratedDocuments.Remove($document)
}

#endregion

#region As-Built Generation

function New-SiteAsBuilt {
    <#
    .SYNOPSIS
        Generates as-built documentation for a site.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$SiteName,

        [Parameter()]
        [string]$SiteLocation,

        [Parameter()]
        [array]$Devices,

        [Parameter()]
        [array]$VLANs,

        [Parameter()]
        [array]$Subnets,

        [Parameter()]
        [switch]$IncludeTOC,

        [Parameter()]
        [switch]$IncludeCrossRefs
    )

    # Build variables
    $variables = @{
        site_name = $SiteName
        site_location = if ($SiteLocation) { $SiteLocation } else { 'Not specified' }
        devices = if ($Devices) { $Devices } else { @() }
        vlans = if ($VLANs) { $VLANs } else { @() }
        subnets = if ($Subnets) { $Subnets } else { @() }
        device_count = if ($Devices) { $Devices.Count } else { 0 }
        vlan_count = if ($VLANs) { $VLANs.Count } else { 0 }
        port_count = 0
    }

    # Calculate port count (handle both hashtables and objects)
    if ($Devices) {
        $portSum = 0
        foreach ($dev in $Devices) {
            if ($dev -is [hashtable]) {
                $portSum += [int]$dev['port_count']
            } elseif ($dev.PSObject.Properties['port_count']) {
                $portSum += [int]$dev.port_count
            }
        }
        $variables['port_count'] = $portSum
    }

    $document = New-Document -TemplateID 'Site-AsBuilt' -Title "$SiteName As-Built Documentation" -Variables $variables -Scope $SiteName

    # Add table of contents if requested
    if ($IncludeTOC) {
        $document | Add-Member -NotePropertyName 'TableOfContents' -NotePropertyValue $document.Sections -Force
    }

    # Add cross-references if requested
    if ($IncludeCrossRefs) {
        $crossRefs = @()
        if ($Devices) {
            foreach ($device in $Devices) {
                $crossRefs += @{
                    Source = 'Device Inventory'
                    Target = $device.hostname
                    Type = 'Device'
                }
            }
        }
        $document | Add-Member -NotePropertyName 'CrossReferences' -NotePropertyValue $crossRefs -Force
    }

    return $document
}

function New-DeviceDocumentation {
    <#
    .SYNOPSIS
        Generates documentation for a single device.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Hostname,

        [Parameter()]
        [string]$Vendor,

        [Parameter()]
        [string]$Model,

        [Parameter()]
        [string]$Serial,

        [Parameter()]
        [string]$Firmware,

        [Parameter()]
        [string]$ManagementIP,

        [Parameter()]
        [string]$Location,

        [Parameter()]
        [array]$Interfaces
    )

    # Calculate port statistics
    $totalPorts = if ($Interfaces) { $Interfaces.Count } else { 0 }
    $connectedPorts = 0
    if ($Interfaces) {
        $connectedPorts = @($Interfaces | Where-Object { [string]::Equals($_.status, 'connected', [System.StringComparison]::OrdinalIgnoreCase) -or [string]::Equals($_.status, 'up', [System.StringComparison]::OrdinalIgnoreCase) }).Count
    }
    $availablePorts = $totalPorts - $connectedPorts
    $utilizationPercent = if ($totalPorts -gt 0) { [Math]::Round(($connectedPorts / $totalPorts) * 100, 1) } else { 0 }

    $variables = @{
        hostname = $Hostname
        vendor = if ($Vendor) { $Vendor } else { 'Unknown' }
        model = if ($Model) { $Model } else { 'Unknown' }
        serial = if ($Serial) { $Serial } else { 'N/A' }
        firmware = if ($Firmware) { $Firmware } else { 'N/A' }
        management_ip = if ($ManagementIP) { $ManagementIP } else { 'N/A' }
        location = if ($Location) { $Location } else { 'N/A' }
        interfaces = if ($Interfaces) { $Interfaces } else { @() }
        total_ports = $totalPorts
        connected_ports = $connectedPorts
        available_ports = $availablePorts
        utilization_percent = $utilizationPercent
    }

    $document = New-Document -TemplateID 'Device-Summary' -Title "$Hostname Device Documentation" -Variables $variables -Scope $Hostname

    # Add structured data
    $document | Add-Member -NotePropertyName 'Hardware' -NotePropertyValue @{
        Hostname = $Hostname
        Vendor = $Vendor
        Model = $Model
        Serial = $Serial
        Firmware = $Firmware
    } -Force

    $document | Add-Member -NotePropertyName 'Interfaces' -NotePropertyValue $Interfaces -Force

    $document | Add-Member -NotePropertyName 'Configuration' -NotePropertyValue @{
        ManagementIP = $ManagementIP
        Location = $Location
    } -Force

    return $document
}

#endregion

#region Report Generation

function New-ExecutiveReport {
    <#
    .SYNOPSIS
        Generates an executive summary report.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$ReportTitle = 'Network Executive Summary',

        [Parameter()]
        [string]$Period,

        [Parameter()]
        [int]$SiteCount = 0,

        [Parameter()]
        [int]$DeviceCount = 0,

        [Parameter()]
        [int]$PortCount = 0,

        [Parameter()]
        [int]$PortUtilization = 0,

        [Parameter()]
        [string[]]$Highlights,

        [Parameter()]
        [string[]]$Recommendations
    )

    $variables = @{
        report_title = $ReportTitle
        period = if ($Period) { $Period } else { (Get-Date).ToString('yyyy-MM') }
        site_count = $SiteCount
        device_count = $DeviceCount
        port_count = $PortCount
        port_utilization = $PortUtilization
        highlights = if ($Highlights) { $Highlights } else { @('No highlights available') }
        recommendations = if ($Recommendations) { $Recommendations } else { @('No recommendations at this time') }
    }

    $document = New-Document -TemplateID 'Executive-Summary' -Title $ReportTitle -Variables $variables -Scope 'Enterprise'

    return $document
}

function New-VLANReport {
    <#
    .SYNOPSIS
        Generates a VLAN reference report.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$SiteName,

        [Parameter()]
        [array]$VLANs
    )

    $variables = @{
        site_name = $SiteName
        vlans = if ($VLANs) { $VLANs } else { @() }
    }

    $document = New-Document -TemplateID 'VLAN-Reference' -Title "$SiteName VLAN Reference" -Variables $variables -Scope $SiteName

    return $document
}

function New-IPAllocationReport {
    <#
    .SYNOPSIS
        Generates an IP allocation report.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$SiteName,

        [Parameter()]
        [array]$Subnets,

        [Parameter()]
        [array]$ReservedAddresses
    )

    $variables = @{
        site_name = $SiteName
        subnets = if ($Subnets) { $Subnets } else { @() }
        reserved_addresses = if ($ReservedAddresses) { $ReservedAddresses } else { @() }
    }

    $document = New-Document -TemplateID 'IP-Allocation' -Title "$SiteName IP Allocation" -Variables $variables -Scope $SiteName

    return $document
}

#endregion

#region Export Functions

function Export-Document {
    <#
    .SYNOPSIS
        Exports a document to a specified format.
    .DESCRIPTION
        Supports Markdown, HTML, Text, CSV, Word (.docx), and PDF formats.
        Word export creates native OpenXML .docx files without external dependencies.
        PDF export generates HTML that can be printed to PDF.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [PSObject]$Document,

        [Parameter(Mandatory)]
        [ValidateSet('Markdown', 'HTML', 'Text', 'CSV', 'Word', 'PDF')]
        [string]$Format,

        [Parameter(Mandatory)]
        [string]$OutputPath
    )

    # Ensure directory exists
    $dir = Split-Path $OutputPath -Parent
    if ($dir -and -not (Test-Path $dir)) {
        New-Item -ItemType Directory -Path $dir -Force | Out-Null
    }

    switch ($Format) {
        'Markdown' {
            $Document.Content | Set-Content -Path $OutputPath -Encoding UTF8
        }
        'HTML' {
            $content = ConvertTo-HTMLDocument -MarkdownContent $Document.Content -Title $Document.Title
            $content | Set-Content -Path $OutputPath -Encoding UTF8
        }
        'Text' {
            $content = ConvertTo-PlainText -MarkdownContent $Document.Content
            $content | Set-Content -Path $OutputPath -Encoding UTF8
        }
        'CSV' {
            $content = ConvertTo-CSVFromMarkdown -MarkdownContent $Document.Content
            $content | Set-Content -Path $OutputPath -Encoding UTF8
        }
        'Word' {
            # Generate .docx using OpenXML
            ConvertTo-WordDocument -MarkdownContent $Document.Content -Title $Document.Title -OutputPath $OutputPath
        }
        'PDF' {
            # PDF export generates print-ready HTML with PDF metadata
            $content = ConvertTo-PDFReadyHTML -MarkdownContent $Document.Content -Title $Document.Title
            $content | Set-Content -Path $OutputPath -Encoding UTF8
            Write-Warning "PDF format: Generated print-ready HTML. Open in browser and use Print > Save as PDF."
        }
    }

    # Update document record
    $Document.Format = $Format

    # Log export
    $null = Add-DocumentHistoryEntry -DocumentID $Document.DocumentID -Action 'Exported' -Details "Exported to $Format at $OutputPath"

    return $OutputPath
}

function ConvertTo-HTMLDocument {
    <#
    .SYNOPSIS
        Converts markdown content to HTML.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$MarkdownContent,

        [Parameter()]
        [string]$Title = 'Document'
    )

    # Simple markdown to HTML conversion
    $html = $MarkdownContent

    # Convert headers
    $html = $html -replace '(?m)^### (.+)$', '<h3>$1</h3>' -replace "`n", "`n"
    $html = $html -replace '(?m)^## (.+)$', '<h2>$1</h2>' -replace "`n", "`n"
    $html = $html -replace '(?m)^# (.+)$', '<h1>$1</h1>' -replace "`n", "`n"

    # Convert bold
    $html = $html -replace '\*\*(.+?)\*\*', '<strong>$1</strong>'

    # Convert tables
    $html = ConvertMarkdownTablesToHTML -Content $html

    # Convert horizontal rules
    $html = $html -replace '^---$', '<hr/>'

    # Convert list items
    $html = $html -replace '^- (.+)$', '<li>$1</li>'

    # Wrap in HTML structure
    $htmlDoc = @"
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>$Title</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 40px; }
        table { border-collapse: collapse; width: 100%; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #4CAF50; color: white; }
        tr:nth-child(even) { background-color: #f2f2f2; }
        h1 { color: #333; }
        h2 { color: #666; border-bottom: 1px solid #ddd; }
        h3 { color: #888; }
        hr { border: none; border-top: 1px solid #ddd; margin: 20px 0; }
    </style>
</head>
<body>
$html
<footer>
    <p><em>Generated by StateTrace Documentation Generator</em></p>
</footer>
</body>
</html>
"@

    return $htmlDoc
}

function ConvertMarkdownTablesToHTML {
    <#
    .SYNOPSIS
        Converts markdown tables to HTML tables.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Content
    )

    # Split content into lines
    $lines = $Content -split "`n"
    $result = @()
    $inTable = $false
    $tableRows = @()

    foreach ($line in $lines) {
        if ($line -match '^\|.*\|$') {
            if (-not $inTable) {
                $inTable = $true
                $tableRows = @()
            }
            # Skip separator rows
            if ($line -notmatch '^\|[\s\-:|]+\|$') {
                $tableRows += $line
            }
        } else {
            if ($inTable) {
                # Convert collected table to HTML
                $htmlTable = '<table>'
                for ($i = 0; $i -lt $tableRows.Count; $i++) {
                    $cells = $tableRows[$i] -split '\|' | Where-Object { $_.Trim() } | ForEach-Object { $_.Trim() }
                    $tag = if ($i -eq 0) { 'th' } else { 'td' }
                    $htmlTable += "<tr>"
                    foreach ($cell in $cells) {
                        $htmlTable += "<$tag>$cell</$tag>"
                    }
                    $htmlTable += "</tr>"
                }
                $htmlTable += '</table>'
                $result += $htmlTable
                $inTable = $false
                $tableRows = @()
            }
            $result += $line
        }
    }

    # Handle table at end of content
    if ($inTable -and $tableRows.Count -gt 0) {
        $htmlTable = '<table>'
        for ($i = 0; $i -lt $tableRows.Count; $i++) {
            $cells = $tableRows[$i] -split '\|' | Where-Object { $_.Trim() } | ForEach-Object { $_.Trim() }
            $tag = if ($i -eq 0) { 'th' } else { 'td' }
            $htmlTable += "<tr>"
            foreach ($cell in $cells) {
                $htmlTable += "<$tag>$cell</$tag>"
            }
            $htmlTable += "</tr>"
        }
        $htmlTable += '</table>'
        $result += $htmlTable
    }

    return $result -join "`n"
}

function ConvertTo-PlainText {
    <#
    .SYNOPSIS
        Converts markdown content to plain text.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$MarkdownContent
    )

    $text = $MarkdownContent

    # Remove markdown formatting
    $text = $text -replace '#+\s+', ''  # Remove header markers
    $text = $text -replace '\*\*(.+?)\*\*', '$1'  # Remove bold
    $text = $text -replace '\*(.+?)\*', '$1'  # Remove italic
    $text = $text -replace '^---$', ('=' * 60)  # Convert horizontal rules (multiline)
    $text = $text -replace '\|', ' | '  # Space out tables

    return $text
}

function ConvertTo-CSVFromMarkdown {
    <#
    .SYNOPSIS
        Extracts tables from markdown and converts to CSV.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$MarkdownContent
    )

    $lines = $MarkdownContent -split "`n"
    $csvLines = @()
    $inTable = $false

    foreach ($line in $lines) {
        if ($line -match '^\|.*\|$') {
            if (-not $inTable) {
                $inTable = $true
            }
            # Skip separator rows
            if ($line -notmatch '^\|[\s\-:|]+\|$') {
                $cells = $line -split '\|' | Where-Object { $_.Trim() } | ForEach-Object { $_.Trim() }
                $csvLines += $cells -join ','
            }
        } else {
            if ($inTable) {
                $csvLines += ''  # Empty line between tables
                $inTable = $false
            }
        }
    }

    return $csvLines -join "`n"
}

function ConvertTo-WordDocument {
    <#
    .SYNOPSIS
        Converts markdown content to a Word (.docx) document using OpenXML.
    .DESCRIPTION
        Creates a native .docx file without requiring Microsoft Word.
        Uses OpenXML format (ZIP archive with XML content).
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$MarkdownContent,

        [Parameter()]
        [string]$Title = 'Document',

        [Parameter(Mandatory)]
        [string]$OutputPath
    )

    # Create temp directory for document parts
    $tempDir = Join-Path $env:TEMP "docx_$(Get-Date -Format 'yyyyMMddHHmmss')_$([Guid]::NewGuid().ToString().Substring(0,8))"
    New-Item -ItemType Directory -Path $tempDir -Force | Out-Null

    try {
        # Create directory structure
        $wordDir = Join-Path $tempDir 'word'
        $relsDir = Join-Path $tempDir '_rels'
        $wordRelsDir = Join-Path $wordDir '_rels'

        New-Item -ItemType Directory -Path $wordDir -Force | Out-Null
        New-Item -ItemType Directory -Path $relsDir -Force | Out-Null
        New-Item -ItemType Directory -Path $wordRelsDir -Force | Out-Null

        # Convert markdown to WordML paragraphs
        $documentXml = ConvertTo-WordML -MarkdownContent $MarkdownContent -Title $Title

        # Create [Content_Types].xml
        $contentTypes = @'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types">
    <Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/>
    <Default Extension="xml" ContentType="application/xml"/>
    <Override PartName="/word/document.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml"/>
    <Override PartName="/word/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml"/>
</Types>
'@
        $contentTypes | Set-Content -LiteralPath (Join-Path $tempDir '[Content_Types].xml') -Encoding UTF8

        # Create _rels/.rels
        $rootRels = @'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="word/document.xml"/>
</Relationships>
'@
        $rootRels | Set-Content -Path (Join-Path $relsDir '.rels') -Encoding UTF8

        # Create word/_rels/document.xml.rels
        $docRels = @'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships">
    <Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/>
</Relationships>
'@
        $docRels | Set-Content -Path (Join-Path $wordRelsDir 'document.xml.rels') -Encoding UTF8

        # Create word/styles.xml
        $stylesXml = @'
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:styles xmlns:w="http://schemas.openxmlformats.org/wordprocessingml/2006/main">
    <w:style w:type="paragraph" w:styleId="Heading1">
        <w:name w:val="heading 1"/>
        <w:basedOn w:val="Normal"/>
        <w:pPr><w:spacing w:before="480" w:after="240"/></w:pPr>
        <w:rPr><w:b/><w:sz w:val="48"/><w:color w:val="2E74B5"/></w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Heading2">
        <w:name w:val="heading 2"/>
        <w:basedOn w:val="Normal"/>
        <w:pPr><w:spacing w:before="360" w:after="120"/></w:pPr>
        <w:rPr><w:b/><w:sz w:val="36"/><w:color w:val="2E74B5"/></w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Heading3">
        <w:name w:val="heading 3"/>
        <w:basedOn w:val="Normal"/>
        <w:pPr><w:spacing w:before="240" w:after="60"/></w:pPr>
        <w:rPr><w:b/><w:sz w:val="28"/><w:color w:val="5B9BD5"/></w:rPr>
    </w:style>
    <w:style w:type="paragraph" w:styleId="Normal">
        <w:name w:val="Normal"/>
        <w:pPr><w:spacing w:after="200" w:line="276" w:lineRule="auto"/></w:pPr>
        <w:rPr><w:sz w:val="22"/><w:rFonts w:ascii="Calibri" w:hAnsi="Calibri"/></w:rPr>
    </w:style>
    <w:style w:type="table" w:styleId="TableGrid">
        <w:name w:val="Table Grid"/>
        <w:tblPr>
            <w:tblBorders>
                <w:top w:val="single" w:sz="4" w:color="auto"/>
                <w:left w:val="single" w:sz="4" w:color="auto"/>
                <w:bottom w:val="single" w:sz="4" w:color="auto"/>
                <w:right w:val="single" w:sz="4" w:color="auto"/>
                <w:insideH w:val="single" w:sz="4" w:color="auto"/>
                <w:insideV w:val="single" w:sz="4" w:color="auto"/>
            </w:tblBorders>
        </w:tblPr>
    </w:style>
</w:styles>
'@
        $stylesXml | Set-Content -Path (Join-Path $wordDir 'styles.xml') -Encoding UTF8

        # Create word/document.xml
        $documentXml | Set-Content -Path (Join-Path $wordDir 'document.xml') -Encoding UTF8

        # Create ZIP archive
        if (Test-Path $OutputPath) { Remove-Item $OutputPath -Force }

        # Use .NET compression
        Add-Type -AssemblyName System.IO.Compression.FileSystem
        [System.IO.Compression.ZipFile]::CreateFromDirectory($tempDir, $OutputPath)
    }
    finally {
        # Cleanup temp directory
        if (Test-Path $tempDir) {
            Remove-Item -Path $tempDir -Recurse -Force -ErrorAction SilentlyContinue
        }
    }
}

function ConvertTo-WordML {
    <#
    .SYNOPSIS
        Converts markdown content to WordML (Office Open XML) format.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$MarkdownContent,

        [Parameter()]
        [string]$Title = 'Document'
    )

    $ns = 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'
    $paragraphs = @()

    # Process lines
    $lines = $MarkdownContent -split "`n"
    $inTable = $false
    $tableRows = @()

    foreach ($line in $lines) {
        $line = $line.TrimEnd()

        # Skip empty lines
        if ([string]::IsNullOrWhiteSpace($line)) {
            continue
        }

        # Handle tables
        if ($line -match '^\|.*\|$') {
            if (-not $inTable) {
                $inTable = $true
                $tableRows = @()
            }
            # Skip separator rows
            if ($line -notmatch '^\|[\s\-:|]+\|$') {
                $tableRows += $line
            }
            continue
        } elseif ($inTable) {
            # End of table, convert to WordML table
            $paragraphs += ConvertTo-WordMLTable -Rows $tableRows
            $inTable = $false
            $tableRows = @()
        }

        # Handle horizontal rules
        if ($line -match '^---+$') {
            $paragraphs += '<w:p><w:pPr><w:pBdr><w:bottom w:val="single" w:sz="6" w:space="1" w:color="auto"/></w:pBdr></w:pPr></w:p>'
            continue
        }

        # Handle headings
        if ($line -match '^(#{1,3})\s+(.+)$') {
            $level = $Matches[1].Length
            $text = [System.Security.SecurityElement]::Escape($Matches[2])
            $styleId = "Heading$level"
            $paragraphs += "<w:p><w:pPr><w:pStyle w:val=`"$styleId`"/></w:pPr><w:r><w:t>$text</w:t></w:r></w:p>"
            continue
        }

        # Handle list items
        if ($line -match '^[-*]\s+(.+)$') {
            $text = [System.Security.SecurityElement]::Escape($Matches[1])
            $paragraphs += "<w:p><w:pPr><w:numPr><w:ilvl w:val=`"0`"/><w:numId w:val=`"1`"/></w:numPr></w:pPr><w:r><w:t>$text</w:t></w:r></w:p>"
            continue
        }

        # Handle numbered list items
        if ($line -match '^\d+\.\s+(.+)$') {
            $text = [System.Security.SecurityElement]::Escape($Matches[1])
            $paragraphs += "<w:p><w:pPr><w:numPr><w:ilvl w:val=`"0`"/><w:numId w:val=`"2`"/></w:numPr></w:pPr><w:r><w:t>$text</w:t></w:r></w:p>"
            continue
        }

        # Regular paragraph with bold handling
        $text = $line
        $runs = @()

        # Process bold text
        while ($text -match '\*\*(.+?)\*\*') {
            $boldIndex = $text.IndexOf('**')
            if ($boldIndex -lt 0) { break }  # Safety check
            $beforeBold = $text.Substring(0, $boldIndex)
            $boldText = $Matches[1]
            $afterIndex = $boldIndex + 2 + $boldText.Length + 2
            $afterBold = if ($afterIndex -lt $text.Length) { $text.Substring($afterIndex) } else { '' }

            if ($beforeBold) {
                $runs += "<w:r><w:t xml:space=`"preserve`">$([System.Security.SecurityElement]::Escape($beforeBold))</w:t></w:r>"
            }
            $runs += "<w:r><w:rPr><w:b/></w:rPr><w:t>$([System.Security.SecurityElement]::Escape($boldText))</w:t></w:r>"
            $text = $afterBold
        }

        if ($text) {
            $runs += "<w:r><w:t xml:space=`"preserve`">$([System.Security.SecurityElement]::Escape($text))</w:t></w:r>"
        }

        if ($runs.Count -gt 0) {
            $paragraphs += "<w:p>$($runs -join '')</w:p>"
        }
    }

    # Handle table at end of content
    if ($inTable -and $tableRows.Count -gt 0) {
        $paragraphs += ConvertTo-WordMLTable -Rows $tableRows
    }

    # Build document
    $documentXml = @"
<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<w:document xmlns:w="$ns">
    <w:body>
        $($paragraphs -join "`n        ")
        <w:sectPr>
            <w:pgSz w:w="12240" w:h="15840"/>
            <w:pgMar w:top="1440" w:right="1440" w:bottom="1440" w:left="1440"/>
        </w:sectPr>
    </w:body>
</w:document>
"@

    return $documentXml
}

function ConvertTo-WordMLTable {
    <#
    .SYNOPSIS
        Converts markdown table rows to WordML table format.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string[]]$Rows
    )

    if ($Rows.Count -eq 0) { return '' }

    $tableXml = '<w:tbl><w:tblPr><w:tblStyle w:val="TableGrid"/><w:tblW w:w="0" w:type="auto"/></w:tblPr>'

    for ($i = 0; $i -lt $Rows.Count; $i++) {
        $cells = $Rows[$i] -split '\|' | Where-Object { $_.Trim() } | ForEach-Object { $_.Trim() }
        $isHeader = ($i -eq 0)

        $tableXml += '<w:tr>'
        foreach ($cell in $cells) {
            $cellText = [System.Security.SecurityElement]::Escape($cell)
            if ($isHeader) {
                $tableXml += "<w:tc><w:tcPr><w:shd w:val=`"clear`" w:fill=`"4472C4`"/></w:tcPr><w:p><w:r><w:rPr><w:b/><w:color w:val=`"FFFFFF`"/></w:rPr><w:t>$cellText</w:t></w:r></w:p></w:tc>"
            } else {
                $tableXml += "<w:tc><w:p><w:r><w:t>$cellText</w:t></w:r></w:p></w:tc>"
            }
        }
        $tableXml += '</w:tr>'
    }

    $tableXml += '</w:tbl>'

    return $tableXml
}

function ConvertTo-PDFReadyHTML {
    <#
    .SYNOPSIS
        Converts markdown to print-ready HTML optimized for PDF export.
    .DESCRIPTION
        Generates HTML with print-specific CSS for optimal PDF output
        when using browser's Print > Save as PDF feature.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$MarkdownContent,

        [Parameter()]
        [string]$Title = 'Document'
    )

    # Convert markdown to HTML content
    $htmlContent = $MarkdownContent

    # Convert headers
    $htmlContent = $htmlContent -replace '(?m)^### (.+)$', '<h3>$1</h3>'
    $htmlContent = $htmlContent -replace '(?m)^## (.+)$', '<h2>$1</h2>'
    $htmlContent = $htmlContent -replace '(?m)^# (.+)$', '<h1>$1</h1>'

    # Convert bold
    $htmlContent = $htmlContent -replace '\*\*(.+?)\*\*', '<strong>$1</strong>'

    # Convert tables
    $htmlContent = ConvertMarkdownTablesToHTML -Content $htmlContent

    # Convert horizontal rules
    $htmlContent = $htmlContent -replace '^---$', '<hr/>'

    # Convert list items
    $htmlContent = $htmlContent -replace '^- (.+)$', '<li>$1</li>'

    # Wrap in print-optimized HTML
    $pdfHtml = @"
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>$Title</title>
    <style>
        @page {
            size: letter;
            margin: 1in;
        }
        @media print {
            body { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
            h1, h2, h3 { page-break-after: avoid; }
            table { page-break-inside: avoid; }
        }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            font-size: 11pt;
            line-height: 1.5;
            color: #333;
            max-width: 8.5in;
            margin: 0 auto;
            padding: 0.5in;
        }
        h1 {
            color: #2E74B5;
            font-size: 24pt;
            border-bottom: 2px solid #2E74B5;
            padding-bottom: 10px;
            margin-top: 0;
        }
        h2 {
            color: #2E74B5;
            font-size: 18pt;
            margin-top: 24pt;
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
        }
        h3 {
            color: #5B9BD5;
            font-size: 14pt;
            margin-top: 18pt;
        }
        table {
            border-collapse: collapse;
            width: 100%;
            margin: 12pt 0;
            font-size: 10pt;
        }
        th {
            background-color: #4472C4;
            color: white;
            padding: 8px;
            text-align: left;
            font-weight: bold;
        }
        td {
            border: 1px solid #ddd;
            padding: 8px;
        }
        tr:nth-child(even) {
            background-color: #f8f8f8;
        }
        hr {
            border: none;
            border-top: 1px solid #ccc;
            margin: 20pt 0;
        }
        li {
            margin: 4pt 0;
        }
        .footer {
            margin-top: 30pt;
            padding-top: 10pt;
            border-top: 1px solid #ccc;
            font-size: 9pt;
            color: #666;
            text-align: center;
        }
    </style>
</head>
<body>
$htmlContent
<div class="footer">
    <p>Generated by StateTrace Documentation Generator - $(Get-Date -Format 'yyyy-MM-dd HH:mm')</p>
    <p><em>Print this page (Ctrl+P) and select "Save as PDF" for PDF output</em></p>
</div>
</body>
</html>
"@

    return $pdfHtml
}

#endregion

#region Document Scheduling

function New-DocumentSchedule {
    <#
    .SYNOPSIS
        Creates a schedule for automatic document generation.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$TemplateID,

        [Parameter()]
        [string]$Scope,

        [Parameter(Mandatory)]
        [ValidateSet('Daily', 'Weekly', 'Monthly')]
        [string]$Frequency,

        [Parameter()]
        [string]$OutputPath,

        [Parameter()]
        [string]$StartTime = '06:00',

        [Parameter()]
        [switch]$IsEnabled
    )

    $template = Get-DocumentTemplate -TemplateID $TemplateID
    if (-not $template) {
        throw "Template '$TemplateID' not found"
    }

    $scheduleId = [Guid]::NewGuid().ToString()

    # Calculate next run time
    $nextRun = Get-NextScheduledTime -Frequency $Frequency -StartTime $StartTime

    $schedule = [PSCustomObject]@{
        ScheduleID = $scheduleId
        TemplateID = $TemplateID
        TemplateName = $template.Name
        Scope = $Scope
        Frequency = $Frequency
        StartTime = $StartTime
        OutputPath = $OutputPath
        IsEnabled = $IsEnabled.IsPresent
        NextRunTime = $nextRun
        LastRunTime = $null
        LastStatus = $null
        CreatedDate = Get-Date
        CreatedBy = $env:USERNAME
    }

    [void]$script:DocumentSchedules.Add($schedule)

    return $schedule
}

function Get-NextScheduledTime {
    <#
    .SYNOPSIS
        Calculates the next scheduled run time.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Frequency,

        [Parameter()]
        [string]$StartTime = '06:00'
    )

    $timeParts = $StartTime -split ':'
    $hour = [int]$timeParts[0]
    $minute = if ($timeParts.Count -gt 1) { [int]$timeParts[1] } else { 0 }

    $now = Get-Date
    $today = $now.Date.AddHours($hour).AddMinutes($minute)

    $nextRun = switch ($Frequency) {
        'Daily' {
            if ($now -lt $today) { $today } else { $today.AddDays(1) }
        }
        'Weekly' {
            $daysUntilNext = (7 - [int]$now.DayOfWeek) % 7
            if ($daysUntilNext -eq 0 -and $now -ge $today) { $daysUntilNext = 7 }
            $today.AddDays($daysUntilNext)
        }
        'Monthly' {
            $firstOfMonth = (Get-Date -Day 1).Date.AddHours($hour).AddMinutes($minute)
            if ($now -lt $firstOfMonth) { $firstOfMonth } else { $firstOfMonth.AddMonths(1) }
        }
    }

    return $nextRun
}

function Get-DocumentSchedule {
    <#
    .SYNOPSIS
        Retrieves document schedules.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$ScheduleID,

        [Parameter()]
        [switch]$EnabledOnly
    )

    $schedules = $script:DocumentSchedules

    if ($ScheduleID) {
        $schedules = $schedules | Where-Object { $_.ScheduleID -eq $ScheduleID }
    }

    if ($EnabledOnly) {
        $schedules = $schedules | Where-Object { $_.IsEnabled }
    }

    return $schedules
}

function Set-DocumentScheduleEnabled {
    <#
    .SYNOPSIS
        Enables or disables a document schedule.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ScheduleID,

        [Parameter(Mandatory)]
        [bool]$IsEnabled
    )

    $schedule = $script:DocumentSchedules | Where-Object { $_.ScheduleID -eq $ScheduleID }
    if (-not $schedule) {
        throw "Schedule '$ScheduleID' not found"
    }

    $schedule.IsEnabled = $IsEnabled

    return $schedule
}

function Remove-DocumentSchedule {
    <#
    .SYNOPSIS
        Removes a document schedule.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$ScheduleID
    )

    $schedule = $script:DocumentSchedules | Where-Object { $_.ScheduleID -eq $ScheduleID }
    if (-not $schedule) {
        throw "Schedule '$ScheduleID' not found"
    }

    [void]$script:DocumentSchedules.Remove($schedule)
}

#endregion

#region History

function Add-DocumentHistoryEntry {
    <#
    .SYNOPSIS
        Adds an entry to the document history log.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$DocumentID,

        [Parameter(Mandatory)]
        [string]$Action,

        [Parameter()]
        [string]$Details
    )

    $entry = [PSCustomObject]@{
        HistoryID = [Guid]::NewGuid().ToString()
        DocumentID = $DocumentID
        Action = $Action
        Details = $Details
        Timestamp = Get-Date
        User = $env:USERNAME
    }

    [void]$script:DocumentHistory.Add($entry)

    return $entry
}

function Get-DocumentHistory {
    <#
    .SYNOPSIS
        Retrieves document history.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$DocumentID
    )

    if ($DocumentID) {
        return $script:DocumentHistory | Where-Object { $_.DocumentID -eq $DocumentID } | Sort-Object Timestamp
    }

    return $script:DocumentHistory | Sort-Object Timestamp -Descending
}

#endregion

#region Statistics

function Get-DocumentStatistics {
    <#
    .SYNOPSIS
        Gets documentation generation statistics.
    #>
    [CmdletBinding()]
    param()

    $documents = @($script:GeneratedDocuments)
    $templates = @($script:DocumentTemplates)
    $schedules = @($script:DocumentSchedules)

    $byTemplate = $documents | Group-Object -Property TemplateID
    $byFormat = $documents | Group-Object -Property Format

    return [PSCustomObject]@{
        TotalDocuments = $documents.Count
        TotalTemplates = $templates.Count
        BuiltInTemplates = @($templates | Where-Object { $_.IsBuiltIn }).Count
        CustomTemplates = @($templates | Where-Object { -not $_.IsBuiltIn }).Count
        ActiveSchedules = @($schedules | Where-Object { $_.IsEnabled }).Count
        TotalSchedules = $schedules.Count
        ByTemplate = @{}
        ByFormat = @{}
    } | ForEach-Object {
        foreach ($group in $byTemplate) { $_.ByTemplate[$group.Name] = $group.Count }
        foreach ($group in $byFormat) { $_.ByFormat[$group.Name] = $group.Count }
        $_
    }
}

#endregion

#region Import / Export Database

function Import-DocumentationDatabase {
    <#
    .SYNOPSIS
        Imports documentation data from a JSON file.
    #>
    [CmdletBinding()]
    param(
        [Parameter(Mandatory)]
        [string]$Path
    )

    if (-not (Test-Path $Path)) {
        return
    }

    try {
        $data = Get-Content -Path $Path -Raw | ConvertFrom-Json

        if ($data.Templates) {
            foreach ($item in $data.Templates) {
                if (-not $item.IsBuiltIn) {
                    [void]$script:DocumentTemplates.Add($item)
                }
            }
        }

        if ($data.Documents) {
            foreach ($item in $data.Documents) {
                [void]$script:GeneratedDocuments.Add($item)
            }
        }

        if ($data.Schedules) {
            foreach ($item in $data.Schedules) {
                [void]$script:DocumentSchedules.Add($item)
            }
        }

        if ($data.History) {
            foreach ($item in $data.History) {
                [void]$script:DocumentHistory.Add($item)
            }
        }
    }
    catch {
        Write-Warning "Failed to import documentation database: $_"
    }
}

function Export-DocumentationDatabase {
    <#
    .SYNOPSIS
        Exports the documentation database to a JSON file.
    #>
    [CmdletBinding()]
    param(
        [Parameter()]
        [string]$Path
    )

    if (-not $Path) {
        $Path = $script:DatabasePath
    }

    if (-not $Path) {
        throw "No database path specified"
    }

    $data = @{
        Templates = @($script:DocumentTemplates | Where-Object { -not $_.IsBuiltIn })
        Documents = @($script:GeneratedDocuments)
        Schedules = @($script:DocumentSchedules)
        History = @($script:DocumentHistory)
        ExportDate = Get-Date
    }

    $data | ConvertTo-Json -Depth 10 | Set-Content -Path $Path

    return [PSCustomObject]@{
        Path = $Path
        TemplateCount = $data.Templates.Count
        DocumentCount = $data.Documents.Count
        ScheduleCount = $data.Schedules.Count
    }
}

#endregion

#region Test Helpers

function Clear-DocumentationData {
    <#
    .SYNOPSIS
        Clears all documentation data (for testing).
    #>
    [CmdletBinding()]
    param()

    $script:DocumentTemplates.Clear()
    $script:GeneratedDocuments.Clear()
    $script:DocumentSchedules.Clear()
    $script:DocumentHistory.Clear()

    # Reload built-in templates
    Initialize-BuiltInTemplates
}

#endregion

# Initialize on module load
Initialize-DocumentationDatabase

# Export functions
Export-ModuleMember -Function @(
    # Initialization
    'Initialize-DocumentationDatabase'

    # Template Engine
    'Expand-DocumentTemplate'

    # Template Management
    'Get-DocumentTemplate'
    'New-DocumentTemplate'
    'Update-DocumentTemplate'
    'Remove-DocumentTemplate'
    'Test-DocumentTemplate'

    # Document Generation
    'New-Document'
    'Get-GeneratedDocument'
    'Remove-GeneratedDocument'

    # As-Built Generation
    'New-SiteAsBuilt'
    'New-DeviceDocumentation'

    # Report Generation
    'New-ExecutiveReport'
    'New-VLANReport'
    'New-IPAllocationReport'

    # Export
    'Export-Document'

    # Scheduling
    'New-DocumentSchedule'
    'Get-DocumentSchedule'
    'Set-DocumentScheduleEnabled'
    'Remove-DocumentSchedule'

    # History
    'Get-DocumentHistory'

    # Statistics
    'Get-DocumentStatistics'

    # Import/Export
    'Import-DocumentationDatabase'
    'Export-DocumentationDatabase'

    # Test Helpers
    'Clear-DocumentationData'
)
