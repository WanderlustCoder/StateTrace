# StateTrace Task Board (Kanban)
This board tracks work items across their lifecycle from backlog to done. Each card carries a role tag (e.g. [Ingestion], [Docs]) and should link to the relevant deliverable (script, document or test). Respect the **WIP=2** limit for the "In Progress" column as described in the resource plan.

## Backlog
_No cards currently in this column._

## Ready
- **Investigate WLLS snapshot/materialize regression** - [Ingestion][Performance] Deliverable: identify why WLLS-A01-AS-01 cold hydrations jumped from ~0.65 s to ~2.7 s after 2025-10-24 autoscale trials, focusing on snapshot/materialize stages and associated caching.
  - 2025-10-24 08:59 MT: Regression observed in `Logs/IngestionMetrics/2025-10-24.json` (`SiteCacheSnapshotDurationMs` 2.19 s, `SiteCacheMaterializeDurationMs` 1.63 s, `SiteCacheFetchDurationMs` 2.72 s). Baseline from 2025-10-23 showed the same host averaging 654 ms across 42 captures. Next: capture detailed snapshot/materialize telemetry differences between BOYO and WLLS and inspect recent DeviceRepository/ParserPersistence changes for WLLS-specific impacts.
  - 2025-10-24 09:33 MT: Focused cold pass (WLLS history cleared, BOYO history backed up) produced `SiteCacheFetchDurationMs` 1,171.86 ms for WLLS-A01-AS-01 (snapshot 859.37 ms, materialize 593.27 ms, host-map 107.02 ms, template 124.21 ms, port-sort 164.30 ms, UI clone 87.54 ms) with `HostMapCandidateMissingCount=1224` and parser cache hits for all 48 existing rows. Remaining WLLS hosts in the run pulled from cache (fetch 33–62 ms, zero candidate-missing counts). Follow-up: trace why the first hydrate still rebuilds all ports despite cached signatures and whether Access snapshot vs. materialize work is the dominant contributor to the residual ~1.17 s.
- **Trial reduced auto-scale ceilings post-batching** - [Ingestion] Deliverable: benchmark run with capped MaxWorkersPerSite/MaxActiveSites appended to Plan B snapshots (targeting WLLS Access commits).
  - 2025-10-24 08:34 MT: Ran `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ThreadCeilingOverride 1 -MaxWorkersPerSiteOverride 1 -MaxActiveSitesOverride 1` from a cold history. `Logs/IngestionMetrics/2025-10-24.json` shows `DatabaseWriteLatency` avg 387 ms (max 1.46 s) versus the prior 353 ms baseline while keeping the thread ceilings at 1. Ingestion history restored post-run so future experiments resume autoscale defaults; follow-up is to inspect per-site hydration timings to confirm serialized Access commits are driving the higher average.
  - 2025-10-24 08:36 MT: Site-level review of `Logs/IngestionMetrics/2025-10-24.json` shows only the first host per site hydrating from Access (`SiteCacheProvider=ADODB` with fetch 888 ms / latency 1.46 s on BOYO-A05-AS-02 and 661 ms / 0.996 s on WLLS-A01-AS-01). The remaining 35 hosts reuse cached dictionaries (`SiteCacheProvider=Cache`, candidate-missing count 0, signature matches 636/1,224), so locking ceilings to one worker serializes the cold hydrate cost and lifts the averages (`DatabaseWriteLatency` 443 ms on BOYO, 360 ms on WLLS) even though commit time stays ~2.4 ms. Next: capture a recommendation (retain multi-worker ceilings or seed pre-hydrate caches) before rerunning the default-autoscale pipeline.
- 2025-10-24 08:38 MT: Recommendation recorded—keep autoscale ceilings >1 so the first-host hydrations overlap instead of serializing. No cache seeding change needed since 36/37 hosts already hit the cache with zero candidate-missing counts. Action: rerun the pipeline with default autoscale to confirm the baseline metrics remain stable.
  - 2025-10-24 08:46 MT: Backed up `Data/IngestionHistory/{BOYO,WLLS}.json` to `*.beforeDefaultAuto.20251024-084408.bak`, regenerated the cold history, and reran the pipeline with autoscale defaults (`ResolvedThreadCeiling=8`, `ResolvedMaxWorkersPerSite=4`). Cold-pass telemetry shows `DatabaseWriteLatency` averaging 897 ms (BOYO) / 882 ms (WLLS) with the first host per site on ADODB (`SiteCacheFetchDurationMs` 896 ms and 2,721 ms respectively) and the remaining 35 hosts on cache (signature matches 636/1,224, candidate-missing count 0). Next: capture a warm replay to confirm cache reuse pulls the averages back toward the 300-400 ms range before closing the card.
  - 2025-10-24 08:52 MT: Warm regression (`Tools/Invoke-WarmRunRegression.ps1 -VerboseParsing`) now confirms the post-fix path—`WarmCacheProviderHitCount=37` with zero signature rewrites and `InterfaceCallDurationMs` dropping from 861 ms (cold) to 485 ms (warm), a 43.65% improvement. The two cold hydrations remain (BOYO-A05-AS-02 ≈2.24 s, WLLS-A01-AS-01 ≈2.0-2.7 s). Follow-up: compare the WLLS cold hydrate against the earlier 0.66 s baseline and decide whether a dedicated WLLS snapshot investigation is required before closing this card.
  - 2025-10-24 08:57 MT: WLLS-A01-AS-01 cold hydrations now fetch in 2.72 s (`Logs/IngestionMetrics/2025-10-24.json`) versus 0.60-0.70 s in the 2025-10-23 corpus (42 captures <19:00 MT averaging 654 ms). Snapshot work alone accounts for ~2.19 s of the spike. Action: open a new investigation (WLLS snapshot/materialize pipeline) to explain the regression before marking this ceiling trial done.
- **Automate warm-run regression in verification pipeline** - [Automation][Telemetry] Deliverable: run `Tools/Invoke-StateTraceVerification.ps1` in scheduled/CI jobs with `-RunWarmRunRegression`, archive `WarmRunTelemetry-*.json`, and enforce `AssertWarmCache` thresholds so cache regressions are caught immediately.
  - 2025-10-23 20:05 MT: Verification harness now maintains `WarmRunTelemetry-latest.json` and `WarmRunTelemetry-latest-summary.json` so downstream automation can ingest the improvement metrics without parsing per-run filenames. Next: plug the script into scheduled verification and alert when cache-hit ratios or improvement percentages fall below targets.
  - 2025-10-23 20:32 MT: Introduced `Tools/Invoke-StateTraceScheduledVerification.ps1` to wrap the verification harness, defaulting to `-SkipTests -VerboseParsing`, emitting a transcript in `Logs\Verification`, and printing the warm-run summary. Action: update the scheduled job/CI workflow to invoke this wrapper and consume the latest-summary JSON for alerting.


## In Progress (WIP=2)
- **Investigate Access commit latency after staging** - [Ingestion][Performance] Started 2025-10-03. Deliverable: chunked staging (24-row) benchmarks captured in Plan B (2025-10-03 and 2025-10-05 snapshots); KPI still unmet with `DatabaseWriteLatency` p95 at 2.16 s (>0.2 s target).
  - 2025-10-04: ParserPersistenceModule now detects Jet vs. ACE provider failures, emits timing telemetry with stage errors, and ParserWorker surfaces `InterfaceBulkChunkSize` overrides.
  - 2025-10-05: Reset ingestion history and reran the BOYO/WLLS corpus; `DatabaseWriteLatency` p95 improved to 2.16 s (max 2.43 s) versus 4.08 s before chunking. `ParseDuration` p95 settled at 3.14 s with WLLS p95 2.78 s. `StageError=ParameterCreationFailed` still fires on 31 hosts via `LiteralFallback`; next focus is the Ready card for reduced ceilings.
  - 2025-10-05 13:24 MT: Trialled overrides (`MaxWorkersPerSiteOverride=2`, `MaxActiveSitesOverride=2`); `DatabaseWriteLatency` p95 climbed to 2.61 s (max 2.77 s) and average 1.02 s, so overrides were reverted after the run. Next up: fix ACE parameter creation failures or test smaller chunks.
  - 2025-10-05 19:10 MT: ParserPersistence now records `StageErrorDetail` with provider info and the Jet parameters that fail to bind, giving us the data needed to target ACE-compatible parameter types.
  - 2025-10-06 16:45 MT: Re-ran mock BOYO/WLLS pipeline after `AuthDefaultVLAN` string conversion; no `InterfacePersistenceFailure` events logged and `InterfaceBulkInsertTiming` omits StageError. Latency still ~3.1 s on WLLS (tuning tracked separately).
  - 2025-10-07: Applied default long-text parameter sizing for ACE/Jet so chunk staging stays parameterized; tests cover the `Add-AdodbParameter` sizing logic. Live Access verification now waits on provider fallback refinements.
  - 2025-10-10 14:35 MT: Precomputed interface seed row values before staging so recordset `AddNew` works from cached arrays. StageDuration averaged 89.7 ms (p95 198.5 ms, max 200.5 ms) with ParameterBind 4.0 ms avg (p95 11.1 ms) and CommandExecute 85.4 ms avg (p95 189.2 ms). `DatabaseWriteLatency` remains 0.61 s avg (p95 1.41 s, max 1.60 s), so the remaining gap sits in Access commit work.
  - 2025-10-10 16:17 MT: Ensured Access indexes for `Interfaces` (`Hostname`, `Hostname+Port`) and `InterfaceHistory` (`Hostname+RunDate`) ahead of bulk commits. Latest pipeline run (mock BOYO/WLLS corpus) reports StageDuration avg 85.6 ms (p95 190 ms, max 192 ms) across 24 chunks, Insert/History averages ~11.9 ms, Cleanup 6.4 ms, Commit 2.8 ms. `DatabaseWriteLatency` improved to 0.54 s avg with p95 1.18 s (max 1.20 s); remaining gap now squarely in Access write latency after staging.
  - 2025-10-10 19:57 MT: Bulk commit path now updates existing rows via SQL instead of delete/reinsert; DeleteDuration averages 74.8 ms (down from ~164 ms) and StageDuration holds at 87 ms avg (p95 190 ms). DatabaseWriteLatency remains elevated (0.59 s avg, p95 1.32 s), so next iterations target Access commit latency hotspots.
  - 2025-10-14 09:48 MT: Planning to introduce a new top-priority core idea, **Documentation Primacy**, making repository guidance the authoritative first step before any code or doc change.
  - 2025-10-14 09:55 MT: Core idea updates published-`docs/Core_Ideas.md` and `AGENTS.md` now lead with **Documentation Primacy**, elevating documentation above the existing pillars.
  - 2025-10-14 09:32 MT: InterfaceSyncTiming now emits per-chunk bulk metrics (Stage 66.5 ms avg / p95 190.8 ms / max 194.5 ms; CommandExecute 63.4 ms avg; InterfaceUpdate 10.9 ms avg; History 9.2 ms avg; TransactionCommit 0.66 ms avg). Average chunk carries 36.6 rows with RecordsetUsed=true across all hosts. DatabaseWriteLatency still 0.48 s avg (p95 1.20 s, max 1.21 s); next focus is profiling LoadExisting/Diff durations to cut the remaining latency.
  - 2025-10-14 09:43 MT: Logging the next action to profile `LoadExistingDurationMs` and `DiffDurationMs` using the latest pipeline telemetry so we can target the dominant diff/load costs before altering the commit path again.
  - 2025-10-14 09:46 MT: Profiling complete — `LoadExistingDurationMs` averages 56 ms (p95 117 ms) while `DiffDurationMs` averages 104 ms (p95 360 ms, max 390 ms). BOYO A05 hosts with 91-row updates (no inserts/deletes) drive the tail; WLLS tops out near 186 ms. Next experiments will concentrate on tightening diff calculations for those 91-row updates.
  - 2025-10-14 09:57 MT: Planning to instrument `Get-InterfaceDiff` (and related helpers) with row-level counters and hash comparisons so we can pinpoint where the 91-row update sets spend 300+ ms; outcome will guide the next commit-path optimization.
  - 2025-10-14 10:11 MT: Implemented signature-based interface comparisons (`Get-InterfaceRowSignature`) plus diff/load telemetry counters (`DiffRowsCompared`, `DiffSignatureDurationMs`, etc.) and added Pester coverage for the new instrumentation. `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` passes; next step is to rerun the BOYO/WLLS pipeline to capture the enriched telemetry.
  - 2025-10-14 10:15 MT: Documenting the plan to clear `Data/IngestionHistory`, run `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`, and analyze the diff telemetry so we can confirm where `DiffDurationMs` time accrues before choosing the next optimization.
  - 2025-10-14 10:20 MT: Reran the BOYO/WLLS pipeline after the reset; 74 `InterfaceSyncTiming` events now show `DiffDurationMs` averaging 164 ms (p95 483 ms, max 656 ms) with `DiffSignatureDurationMs` averaging 105 ms (p95 275 ms). The 96-row BOYO cohorts remain the tail (`DiffDurationMs` avg 470 ms / p95 655 ms; signature cost avg 218 ms) while stage work stays ~70 ms avg (p95 192 ms). `DatabaseWriteLatency` sits at 605 ms avg (p95 1.44 s), confirming the next focus is trimming diff/signature cost.
  - 2025-10-14 10:32 MT: Planning a diff/signature optimization pass—review `Get-InterfaceDiff` and helpers for repeated signature work, prototype per-host caching of existing row signatures, and update telemetry/tests to confirm lower `DiffSignatureDurationMs` before the next pipeline rerun.
  - 2025-10-14 10:39 MT: Implemented signature reuse (`Get-InterfaceSignatureFromValues`) and reran tests/pipeline. `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` passes; the latest BOYO/WLLS run (37 `InterfaceSyncTiming` events) shows `DiffSignatureDurationMs` averaging 34.9 ms (p95 74.2 ms, max 92.4 ms) with the 96-row cohort down to 65.3 ms avg (p95 89.8 ms). `DiffDurationMs` now averages 153 ms (p95 378 ms) while `DatabaseWriteLatency` remains ~614 ms avg (p95 1.45 s), so the follow-up will target the remaining diff/comparison cost.
- 2025-10-23 13:44 MT: Reran `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches`; warm-pass `InterfaceSiteCacheMetrics` in `Logs/IngestionMetrics/2025-10-23.json` still report `Provider=ADODB`, `HostMapSignatureMatchCount=0`, and rewrite counts 636 (BOYO) / 1,224 (WLLS) with hydrations holding at ~0.68 s / 0.56 s. `InterfaceSiteCacheReuseAttempt` logged script cache hits (BOYO 11/12, WLLS 24/25) but no shared-store hits/adoption, and shared-store telemetry continues to emit `InitNewStore` with `EntryCount=0`. Parser samples show `ParserLoadCacheHit=true` and `ParserExistingRowCount=48` while DeviceRepository marks `PreviousHostEntryPresent=false`. Action: inspect the DeviceRepository reuse path (`Get-InterfaceSiteCache` host lookup, `Set-InterfaceSiteCacheHost`) to reconcile the host lookup mismatch and determine whether the shared-store reset is discarding entries.
- 2025-10-23 14:05 MT: Warm-run helper now surfaces cache hits (`Provider=Cache`, `HostMapSignatureMatchCount=636/1224`, `HydrationDurationMs=0`) in `Logs/IngestionMetrics/2025-10-23.json` (`13:59:01 MT`). `InterfaceSiteCacheReuseState` shows the cached host dictionaries and `InterfaceSyncTiming` reports matching `SiteCacheComparisonSignatureMatchCount`. Next action: review `DatabaseWriteBreakdown.SiteCache*` fields for the same run and update docs/task board once downstream metrics reflect the cache-hit state (then close this investigation).
- 2025-10-23 15:12 MT: Completed the DatabaseWriteBreakdown follow-up. Warm-run entries in `Logs/IngestionMetrics/2025-10-23.json` (`13:58:51.984-06:00` BOYO-A05-AS-35 and `13:58:58.744-06:00` / `13:59:01.266-06:00` WLLS-A03-AS-33/WLLS-A05-AS-45) now report `SiteCacheProvider=Cache`, `SiteCacheHostMapSignatureMatchCount=636/1224`, and zero candidate-missing counts, matching `InterfaceSiteCacheMetrics`. Docs updated; cache reuse investigation closed unless new regressions surface.
- 2025-10-23 15:24 MT: Ran the preserved-session cold + warm replay (`Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-20251023-1524.json`). `DatabaseWriteBreakdown` shows cold-pass `InterfaceCallDurationMs` averaging 362.96 ms (p95 915.20 ms, max 1.26 s) versus warm-pass 140.11 ms (p95 170.43 ms, max 374.09 ms) with all warm hosts reporting `SiteCacheProvider=Cache`. No regressions noted; consider automating the warm-run check so future cache changes surface interface-call deltas automatically.
- 2025-10-23 17:35 MT: Fixed the warm-run telemetry helper to enumerate site snapshots via `@($sites)` (avoiding the `.ToArray()` runtime failure inside the pipeline harness) and reran `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -RunWarmRunRegression -WarmRunRegressionOutputPath Logs/IngestionMetrics/WarmRunTelemetry-verify.json`. The regression now completes in-process with 37/37 warm hosts reporting `SiteCacheProvider=Cache`, `WarmCacheProviderHitCount=37`, and `WarmSignatureMatchMissCount=0`; cold vs. warm `InterfaceCallDurationMs` averages fell from 302.255 ms to 297.552 ms (1.56% / 4.703 ms improvement). Next action: hook `Tools/Invoke-WarmRunRegression.ps1` into CI so the preserved-session cache guardrails run automatically.
- 2025-10-23 17:49 MT: Added `Tools/Invoke-StateTraceVerification.ps1` as the scheduled verification entry point. It shells `Tools/Invoke-StateTracePipeline.ps1` with `-RunWarmRunRegression`, generates a timestamped export under `Logs/IngestionMetrics/`, and splats relative paths so the warm-run helper avoids duplicating drive roots. First verification trial (`Tools/Invoke-StateTraceVerification.ps1 -SkipTests -VerboseParsing`) failed the warm-run assertion: cold `InterfaceCallDurationMs` avg 302.120 ms vs. warm 309.457 ms, so no `WarmRunTelemetry-*.json` was emitted. Follow-up: diagnose the preserved-session regression and restore the expected warm-pass improvement before turning the new script on in CI.
- 2025-10-23 15:50 MT: Warm-run helper now summarizes cold vs. warm latency and asserts cache reuse (`Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches -AssertWarmCache -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-latest.json`). Latest run logged `WarmRunComparison` with cold `InterfaceCallDurationMs` avg 416.104 ms (p95 903.201 ms, max 1.47 s) against warm 137.784 ms (p95 178.685 ms, max 0.37 s), confirming a 66.89% improvement and 37/37 cache hits. The helper now fails when providers fall back, signature matches disappear, rewrites return, or warm averages exceed cold.
- 2025-10-23 15:56 MT: Published `Tools/Invoke-WarmRunRegression.ps1` wrapper so CI/backlog automation can call the warm-run guard directly; it stamps telemetry to `Logs/IngestionMetrics/WarmRunTelemetry-<timestamp>.json` and echoes the cold vs. warm summary (`Cold avg 361.699 ms`, `Warm avg 137.636 ms`, `61.95%` improvement on the latest run). Next step is to hook this script into the scheduled verification workflow so regressions fail fast.
- 2025-10-23 16:05 MT: Documented the regression wrapper in `AGENTS.md` and the operator runbook; expected warm-run results now call out >=60% InterfaceCallDuration improvement with `SiteCacheProvider=Cache` for every host. Remaining work: add the wrapper to the scheduled verification job and capture pass/fail telemetry in CI.
- 2025-10-23 16:32 MT: `Tools/Invoke-StateTracePipeline.ps1` now accepts `-RunWarmRunRegression` (and optional `-WarmRunRegressionOutputPath`) so the preserved-session cache guard can run immediately after the baseline ingestion pass. Next action is to update the scheduled verification configuration/CI harness to set the switch and archive the emitted `WarmRunTelemetry-*.json` summary.
- 2025-10-23 16:41 MT: `Split-RawLogs` skips `Logs\WarmRunTelemetry-*` helper artifacts, eliminating the transcript file lock that blocked the first dry run. After hardening the helper with `Collect-TelemetryForPass` (polling plus timestamp-agnostic fallback) the preserved-session pipeline run now appends the expected `InterfaceSiteCacheMetrics`/`DatabaseWriteBreakdown`, but `SharedCacheSnapshot:PostColdPass` still reports `EntryCount=0` and the warm pass hydrates `BOYO-A05-AS-02`/`WLLS-A01-AS-01` from ADODB (636/1,224 rewrites), yielding `Warm InterfaceCallDurationMs avg 328.735 ms` versus cold `296.556 ms` and tripping `AssertWarmCache`. Follow-up: trace why `Get-SharedSiteInterfaceCacheStore` is empty in the pipeline-launched regression and restore cache reuse before wiring the switch into CI.
- 2025-10-23 14:25 MT: Threaded ParserPersistence cache resolve telemetry (entry type, port signature samples, cache comparison counters) through DeviceLogParser and refreshed module tests. Follow-up: rerun `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches` to confirm warm runs surface non-zero `SiteCacheComparisonSignatureMatchCount` before closing the cache reuse investigation.
- 2025-10-23 12:07 MT: Reran the preserved-session warm telemetry helper (`Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches`). `Logs/IngestionMetrics/2025-10-23.json` still shows `SiteCacheComparisonSignatureMatchCount=0` for WLLS while `SiteCacheHostMapSignatureRewriteCount=1,224` and `SiteCacheHostMapCandidateMissingCount=275,400`, despite reuse telemetry capturing 25 hosts / 1,224 ports in cache. Action: instrument ParserPersistence's candidate-missing path (e.g., `HostSnapshotMissing` diagnostics) to identify why cached dictionaries fail the comparison and outline the required resolve fix.
- 2025-10-23 12:36 MT: ParserPersistence now emits `SiteCacheExistingRow*` telemetry and tags `SiteCacheHostMapCandidateMissingSamples` with parser context; ParserPersistence/DeviceLogParser tests pass with the new instrumentation. Follow-up: rerun `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches` to review the parser-side fields and reconcile them with the DeviceRepository `HostSnapshotMissing` diagnostics.
- 2025-10-23 12:38 MT: Warm-run helper rerun after the parser instrumentation; WLLS `InterfaceSyncTiming` events now show `SiteCacheExistingRowCount=24` and candidate-missing samples annotated with `ParserExistingRowSource=CacheInitial` / `ParserLoadCacheHit=true` while DeviceRepository still reports `HostSnapshotMissing`. Next step: follow the DeviceRepository hydration/signature reuse path to reconcile the mismatch now that parser context confirms cached host dictionaries exist during diff.
- 2025-10-14 10:41 MT: Planning the next comparer optimization-capture baseline diff telemetry (DiffDurationMs avg 153 ms / p95 378 ms; 96-row cohorts 318 ms avg / p95 501 ms) and outline experiments to reuse existing row projections or avoid redundant PSCustomObject allocations before rebenchmarking. 
  - 2025-10-14 10:46 MT: Deferred PSCustomObject creation for unchanged ports (new helper builds rows only for inserts/updates) and reran validation. `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` passes; BOYO/WLLS benchmark (37 `InterfaceSyncTiming` events >=10:42 MT) reports `DiffDurationMs` avg 152.6 ms (p95 408 ms, max 464 ms) with the 96-row cohort at 320.3 ms avg (p95 448.9 ms). `DiffSignatureDurationMs` remains ~36.1 ms avg (p95 77.4 ms). DatabaseWriteLatency stays elevated (avg 602 ms, p95 1.28 s), reinforcing that further comparer reductions or load batching are still required.
  - 2025-10-14 10:54 MT: Planning an incremental-loading experiment so switch/site details surface immediately while ports stream in. Drafted outline covers parser batching, a bottom-of-window loading indicator, telemetry (`PortsQueued`, `BatchesRemaining`), and validation benchmarks. Risks: Access batching must stay offline-first; UI needs a resilient subscriber path; fall back to the current all-at-once load if port batches fail. Next action is to assess feasibility and spike the parser/UI wiring.
  - 2025-10-14 11:19 MT: Logging the upcoming spike work per Documentation Primacy. Scope: emit `PortBatchReady` telemetry after each `InterfaceBulkInsertTiming` commit, enable `DeviceRepositoryModule` to serve cached batch slices, and prep the UI for a bottom loading indicator while ports stream in. Tests and benchmark rerun will follow once the wiring lands.
  - 2025-10-14 11:44 MT: Incremental-loading spike landed. ParserPersistence now stages per-chunk batches via what is now `Set-InterfacePortStreamData` (renamed from `Stage-InterfacePortStreamData`) and emits `PortBatchReady`; DeviceRepository streams cached batches; the UI shows a bottom progress indicator as ports append. Updated `DeviceRepositoryModule.Tests.ps1` and `ParserPersistenceModule.Tests.ps1` cover the streaming helpers and telemetry; `Invoke-Pester` for both suites passes. Next move: capture a BOYO/WLLS pipeline run to measure perceived load-time improvements and document UI behaviour in the operators' runbook.
  - 2025-10-14 12:20 MT: Planning the BOYO/WLLS pipeline rerun to collect incremental-loading telemetry, track UI load indicator behaviour, and log outcomes in the operators' runbook once metrics are gathered.
  - 2025-10-14 13:12 MT: Completed the BOYO/WLLS rerun after clearing `Data/IngestionHistory`; captured 224 `InterfaceSyncTiming` events (StageDuration avg 61 ms / p95 194 ms, DiffDuration avg 138 ms / p95 449 ms) and 224 `DatabaseWriteLatency` entries (avg 610 ms, p95 1.86 s, max 3.87 s). Logged 31 `PortBatchReady` events (PortsCommitted avg 43.6, EstimatedBatchCount max 4). Next action: record findings in Plan B and publish the operators' incremental-loading runbook notes.
  - 2025-10-14 13:25 MT: Published `docs/StateTrace_Operators_Runbook.md` detailing the incremental port streaming workflow (indicator text/progress states, telemetry validation, escalation guidance) so operators can verify the staggered load while the Access latency work continues.
  - 2025-10-14 13:32 MT: Planning a telemetry deep-dive to isolate the 1.8 s+ DatabaseWriteLatency tail (focus on BOYO-A05 cohort, Diff/LoadExisting hotspots) before drafting mitigation experiments.
  - 2025-10-14 13:38 MT: Telemetry review shows BOYO-A05-AS-{05,15,25,35,45,55} averaging 1.06-1.49 s latency (p95 up to 3.87 s) with `DiffDurationMs` 300-375 ms and `LoadExistingDurationMs` ~190 ms per 92-row batches; WLLS-A05 peers sit 0.97-1.06 s with similar row counts. Commit durations stay <6 ms, so next experiments should target diff/load reductions or commit SQL batching, and consider emitting multiple `PortBatchReady` beats for >90-row devices.
  - 2025-10-14 13:45 MT: Updated `docs/Core_Ideas.md` and `AGENTS.md` to add the **Approved PowerShell Verbs** pillar, reaffirming that exported commands must use approved verbs and that remediation plans must be documented when legacy verbs surface.
  - 2025-10-14 14:05 MT: Documenting the fix plan for the site cache experiment—rework `ParserPersistenceModule.Tests.ps1` mocks so cache dictionaries stay in module scope, adjust ParserPersistence wiring as needed, and rerun `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` to confirm the caching telemetry path before the next pipeline benchmark.
  - 2025-10-14 14:42 MT: Finished the site cache regression—`ParserPersistenceModule.Tests.ps1` now exercises cache hits via TelemetryModule output in `TestDrive`; `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` passes (13/13) and the caching plan can proceed to a pipeline rerun for telemetry validation.
  - 2025-10-14 13:55 MT: Planning an approved-verb audit across `Modules/*.psm1` exports to surface legacy names; findings and remediation backlog will be recorded after the scan.
  - 2025-10-14 14:05 MT: Approved-verb audit complete. Only `Stage-InterfacePortStreamData` (DeviceRepositoryModule) uses the unapproved `Stage` verb; queued renaming work to adopt an approved verb (proposal: `Set-` or `Initialize-`). Remaining exports already comply.
  - 2025-10-14 14:12 MT: Planning the verb remediation: rename `Stage-InterfacePortStreamData` to an approved verb (`Set-InterfacePortStreamData`), update all module/test/UI references, refresh telemetry docs, and rerun targeted Pester suites.
  - 2025-10-14 14:20 MT: Renamed the helper to `Set-InterfacePortStreamData`, updated ParserPersistence, MainWindow, and tests, and reran `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` plus `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` (both passing). Docs now reference the approved verb.
  - 2025-10-14 14:30 MT: Planning the next latency experiment-design per-site caching or Access-side temp-table reuse to cut `DiffDurationMs` / `LoadExistingDurationMs` for the 92-row BOYO cohorts; outline approach and validation steps before implementation.
  - 2025-10-14 14:40 MT: Design options captured-(1) site-level existing-row cache via DeviceRepository hydrated once per run with telemetry hook `LoadCacheHit`; (2) Access temp-table diff path (`LEFT JOIN`/`EXCEPT`) to offload comparisons. Both will need extra telemetry (`DiffSqlDurationMs`) and cache-invalidation tests before coding.
  - 2025-10-14 15:05 MT: Logging the decision to pursue the site-level existing-row cache experiment first. Scope covers hydrating `Get-InterfacesForHostsBatch` once per site run, storing normalized signatures for ParserPersistence reuse, adding telemetry (`LoadCacheHit`, `LoadCacheMiss`, `CachedRowCount`), and writing cache invalidation tests before implementation proceeds.
  - 2025-10-14 15:20 MT: Planning to clear `Data/IngestionHistory` and rerun `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` so the new site-cache telemetry (`LoadCacheHit`, `LoadCacheMiss`, `CachedRowCount`, `CachePrimedRowCount`) is captured before pursuing additional diff-path changes.
  - 2025-10-14 16:58 MT: DeviceRepository now hydrates site caches via the active ADODB connection (`Invoke-WithAccessExclusiveRetry` guard). Latest BOYO/WLLS rerun (80 `InterfaceSyncTiming` events) shows cache hits 62 / misses 18 (BOYO 12 hits / 18 misses, WLLS 50 hits / 0 misses). LoadExisting averaged 21.3 ms overall (BOYO 56.6 ms); StageDuration averaged 101.6 ms; no exclusive-lock warnings emitted. Next focus: continue trimming BOYO cache misses and load/diff durations.
  - 2025-10-14 17:20 MT: Planning the next site cache iteration—review DeviceRepository/ParserPersistence cache wiring on BOYO hosts, identify why 18 misses persist, and draft adjustments to pre-warm or reuse caches before altering diff logic. Will log findings and proposed mitigations before implementing.
  - 2025-10-14 17:46 MT: Implemented cache refresh + empty-host handling in ParserPersistence so missing hosts trigger a one-time `Get-InterfaceSiteCache -Refresh` and zero-row entries count as cache hits. Added `LoadCacheRefreshed` telemetry field and new Pester coverage (ParserPersistence + DeviceRepository suites both passing). Next step: rerun BOYO/WLLS pipeline (history cleared) to confirm miss count drops and capture refreshed telemetry.
## Blocked
_No cards currently in this column._ Add a note explaining the dependency or issue for each blocked card.

## Done
- **Align parser/interface tests with streaming caches** - [Automation][Tests] Completed 2025-10-15. Deliverable: updated Pester expectations (`Modules/Tests/DeviceDetailsModule.Tests.ps1`, `Modules/Tests/ParserPersistenceModule.Tests.ps1`) now reflect the ObservableCollection streaming contract and clear site caches before verifying SQL command counts; `Invoke-Pester Modules/Tests` passes end-to-end.
- **Suppress duplicate-only reruns after spool reset** - [Automation][Telemetry] Completed 2025-10-06. Deliverable: DeviceLogParser duplicate guard avoids extra Access opens, Pester coverage ensures duplicates skip `ParseDuration`, and the 2025-10-06 20:35Z rerun logged only `SkippedDuplicate` telemetry across two verification passes.
- **Identity option scorecard for acknowledgements** - [Security][Docs] Completed 2025-10-04. Deliverable: weighted scorecard and recommendation in `docs/StateTrace_Acknowledgement_Identity_Options.md` plus Plan F updates in `docs/StateTrace_Consolidated_Plans.md`.
- **Unified ParserPersistence command-set caching** - [Ingestion][Automation] Completed 2025-10-02. Deliverable: `Modules/ParserPersistenceModule.psm1` command reuse + persistence failure logging, `Modules/DeviceLogParserModule.psm1` catch instrumentation, refreshed tests (`Modules/Tests/ParserPersistenceModule.Tests.ps1`, `Modules/Tests/ParserWorker.Tests.ps1`), and Plan B updates.
- **Add spool reset helper for benchmark reruns** - [Automation][Docs] Completed 2025-10-03. Deliverable: -ResetExtractedLogs switch in Tools/Invoke-StateTracePipeline.ps1 plus README/Plan B updates.
- **Profile Access bulk insert timing** - [Ingestion][Automation] Completed 2025-10-03. Deliverable: InterfaceBulkInsertTiming telemetry in Modules/ParserPersistenceModule.psm1 and 2025-10-03 Plan B snapshot.
- **Trialed parser concurrency overrides with mock slice corpus** - [Ingestion][Docs] Completed 2025-10-01. Deliverable: metrics summary in `docs/StateTrace_Consolidated_Plans.md#plan-b-performance-ingestion-scale` (baseline vs. manual overrides, single-thread duplicate guard).
- **Documented concurrency override workflow** - [Docs][Automation] Completed 2025-10-01. Deliverable: quick-reference updates in `docs/README.md` and `AGENTS.md`, session log `docs/agents/sessions/2025-10-01_session-0002.md`.
- **Verified database creation flow** - [Data][Automation] Completed 2025-10-01. Deliverable: host normalisation retest captured in `docs/StateTrace_Consolidated_Plans.md#plan-b-performance-ingestion-scale` and session log `docs/agents/sessions/2025-10-01_session-0001.md`.
- **Stress-tested autoscaling parser settings** - [Ingestion] Completed 2025-09-30. Deliverable: stress-test snapshot recorded in `StateTrace_Consolidated_Plans.md#plan-b-performance-ingestion-scale` (24-thread profile; DatabaseWriteLatency p95 ~564 ms, above 200 ms target).
- **Summarised pipeline script and autoscaling workflow** - [Docs] Completed 2025-09-30. Deliverable: execution playbook recorded in `StateTrace_Consolidated_Plans.md#plan-b-performance-ingestion-scale`.
- **Fix integer parameter binding in persistence layer** - [Automation] Completed 2025-09-30. Deliverable: parameterised ParserPersistenceModule with passing `Invoke-Pester Modules/Tests` and `Tools/Invoke-StateTracePipeline.ps1 -SkipTests`.
- **Refactored parser persistence to parameterised ADODB commands** - [Automation] Completed 2025-09-30. Deliverable: updated persistence helpers and passing tests.
- **Added orchestration script Tools/Invoke-StateTracePipeline.ps1** - [Automation] Completed 2025-09-30. Validated via `powershell -File Tools/Invoke-StateTracePipeline.ps1 -SkipParsing -VerboseParsing`.
- **Applied plan status header to each active plan** - [Docs] Completed 2025-09-30. All planning documents now include status and last reviewed fields.
  - 2025-10-14 19:30 MT: Planning the BOYO/WLLS cache-validation rerun. Will clear `Data/IngestionHistory`, execute `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`, and capture `LoadCacheHit`, `LoadCacheMiss`, and `LoadCacheRefreshed` telemetry for documentation once metrics are collected.
  - 2025-10-14 19:37 MT: Completed the BOYO/WLLS cache-validation run. `InterfaceSyncTiming` emitted 37 events with `LoadCacheHit=true` for every host (no misses or refreshes); `LoadExistingDurationMs` averaged 0.20 ms (p95 0.42 ms) thanks to the site cache. `DatabaseWriteLatency` averaged 1.67 s with p95 10.1 s, driven by BOYO-A05-AS-02 (11.2 s) and WLLS-A01-AS-01 (10.1 s); follow-up focuses on trimming the diff/commit tail.
  - 2025-10-14 19:40 MT: Planning diff/update tail investigation. Will break down `DiffDurationMs`, `DiffSignatureDurationMs`, and per-host outliers (BOYO-A05-AS-02, WLLS-A01-AS-01) to propose targeted optimizations (e.g., cached signatures, batched updates) before coding.
  - 2025-10-14 19:45 MT: Diff/update telemetry review complete. 96-row cohorts (12 hosts) average `DiffDurationMs` 290 ms with `BulkCommandExecuteDurationMs` 185 ms; 48-row cohort averages 136 ms diff / 85 ms command. Cache kept `LoadExistingDurationMs` <0.2 ms across the board. `DatabaseWriteLatency` remains high (avg 1.67 s, p95 10.1 s) with outliers on BOYO-A05-AS-02 (11.2 s) and WLLS-A01-AS-01 (10.1 s) despite per-chunk commits <0.2 s, suggesting the latency counter now includes extra work (likely post-commit bookkeeping) or is mis-measured. Next steps: audit `DatabaseWriteLatency` measurement in ParserPersistence/DeviceLogParser and consider additional telemetry around per-host post-commit phases.
  - 2025-10-14 19:53 MT: Planning DatabaseWriteLatency instrumentation audit. Will trace stopwatch start/stop in ParserPersistenceModule and DeviceLogParserModule, verify timing includes only commit work, and identify missing telemetry for post-commit phases before modifying code.
  - 2025-10-14 19:58 MT: Instrumentation audit findings: DatabaseWriteLatency stopwatch in DeviceLogParserModule.psm1:1165-1234 spans the entire transaction, covering Update-DeviceSummaryInDb, Update-InterfacesInDb, cache refresh, and streaming calls (Set-InterfacePortStreamData). InterfaceSyncTiming focus (ParserPersistenceModule.psm1:1254-1307) tracks diff/bulk timings only, so summary + stream work is unaccounted for in telemetry—explaining the 1.7-11 s gap. Need to add telemetry around summary writes and post-commit stream/cache hooks, then validate whether commit time or UI streaming drives the tail before optimizing.
  - 2025-10-14 20:17 MT: Planning telemetry expansion—add summary write timings (`DeviceLogParserModule.psm1:1180-1230`), measure cache refresh + streaming hooks (`ParserPersistenceModule.psm1:1812-1877`, `DeviceRepositoryModule.psm1:459-520`), and emit a combined payload (e.g., `DatabaseWriteBreakdown`) before rerunning the pipeline.
  - 2025-10-14 20:37 MT: Running telemetry validation with new breakdown instrumentation. Will clear Data/IngestionHistory, execute Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs, and capture DatabaseWriteBreakdown plus updated InterfaceSyncTiming fields for documentation.
  - 2025-10-14 20:44 MT: Telemetry run complete. `DatabaseWriteBreakdown` now emitting for 37 devices; SummaryDuration avg 34 ms (p95 55 ms), StreamDispatch avg 214 ms (p95 472 ms), SiteCacheUpdate avg 1.9 ms. DatabaseWriteLatency still avg 1.27 s (p95 7.24 s) driven by BOYO-A05-AS-02 and WLLS-A01-AS-01, where InterfaceCallDurationMs exceeds 7.2 s despite diff/commit metrics staying sub-200 ms -- indicates work queued after diff, likely recordset/stream cloning. Next: inspect DeviceRepository stream cloning and potential UI dispatch lag.
  - 2025-10-14 21:05 MT: Planning the streaming-dispatch dive before changes-review DeviceRepositoryModule (Set-InterfacePortStreamData queue + cloning), InterfaceModule dispatcher hooks, and MainWindow append workflow; capture missing telemetry ideas (dispatch queue depth, per-batch render) and enumerate risks like UI thread contention.
  - 2025-10-14 21:28 MT: Analysis complete. ParserPersistence builds `$uiRows` by cloning every port (Add-Member per property) and DeviceRepository immediately reclones the same records before enqueuing batches, so the double clone cost lands inside `InterfaceCallDurationMs` (e.g., BOYO-A05-AS-02 shows 7.2 s call vs. 94 ms StreamDispatch in Logs/IngestionMetrics/2025-10-14.json). Dispatcher loops still add items one-by-one. Next focus: add telemetry for clone/queue duration and test lighter projections or bulk ObservableCollection inserts to collapse the gap.
  - 2025-10-14 21:34 MT: Planning follow-up: instrument ParserPersistence clone time (`UiCloneDurationMs`), teach DeviceRepository to capture stream clone/queue timings and expose `Get-LastInterfacePortStreamMetrics`, reuse ParserPersistence-supplied `psobject` rows when safe, and thread the new metrics into DeviceLogParser breakdown/InterfaceSyncTiming before validating with updated Pester coverage.
  - 2025-10-14 22:06 MT: Planning telemetry validation run now that clone/stream metrics are wired through DeviceLogParser and ParserPersistence. Will clear `Data/IngestionHistory`, execute `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`, and review `StreamCloneDurationMs`, `UiCloneDurationMs`, and `InterfaceCallDurationMs` to identify the dominant tail contributors before proposing optimizations.
  - 2025-10-14 22:24 MT: Telemetry run executed after clearing `Data/IngestionHistory`. `InterfaceCallDurationMs` averaged 1.22 s (p95 1.68 s, max 7.21 s on BOYO-A05-AS-02 and WLLS-A01-AS-01) while `StreamDispatchDurationMs` remained low (avg 16.69 ms, p95 94.68 ms, max 532.09 ms). `DiffDurationMs` averaged 129 ms (p95 369 ms); `LoadExistingDurationMs` averaged 49.7 ms (p95 219 ms). No `InterfacePortStreamMetrics` events were emitted, so `StreamCloneDurationMs` / `StreamQueueDurationMs` are missing—next step is to trace why the new helper never persists telemetry before optimizing the clone path.
  - 2025-10-14 22:32 MT: Planning follow-up investigation into the missing `InterfacePortStreamMetrics` payload. Will review `ParserPersistenceModule.psm1` telemetry caching and `DeviceRepositoryModule.psm1::Set-InterfacePortStreamData` emission logic, confirm test coverage expectations, and outline the fix path before changing any module code.
  - 2025-10-14 22:48 MT: DeviceRepository now writes `InterfacePortStreamMetrics` via TelemetryModule and ParserPersistence refreshes `LastInterfaceSyncTelemetry` after stream metrics arrive. Unit suites (`DeviceRepositoryModule.Tests.ps1`, `ParserPersistenceModule.Tests.ps1`) pass; preparing a fresh BOYO/WLLS pipeline run to confirm events land and to capture the new clone metrics.
  - 2025-10-15 10:27 MT: Post-fix pipeline complete (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`). Logged 37 `InterfacePortStreamMetrics` events with `StreamCloneDurationMs` avg 24.97 ms (p95 50.83 ms, max 60.55 ms) and `StreamStateUpdateDurationMs` avg 0.25 ms (p95 0.51 ms). `RowsCloned` remained zero (all batches reused parser-provided rows). `DatabaseWriteBreakdown.InterfaceCallDurationMs` still averages 1.25 s (p95 1.81 s, max 10.30 s), so the long tail persists beyond clone/state costs-next work item is to profile dispatcher batching and UI append paths.
  - 2025-10-15 11:06 MT: Documenting upcoming UI dispatch profiling step-will trace dispatcher batch handling in `Main/MainWindow.ps1` and `Modules/InterfaceModule.psm1`, note missing telemetry, and outline instrumentation/tests before making code changes.
  - 2025-10-15 12:08 MT: Implemented dispatcher instrumentation. `Main/MainWindow.ps1` now times per-batch UI appends and loading-indicator updates, and DeviceRepository stores/emits `InterfacePortDispatchMetrics` (batch size, dispatcher duration, append/indicator timings). Ran `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` and `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` (pass). Next: capture telemetry during a UI session or pipeline replay to confirm whether dispatcher costs explain the remaining `InterfaceCallDurationMs` tail.
  - 2025-10-15 12:18 MT: Planning telemetry validation run for dispatcher metrics-clear `Data/IngestionHistory`, execute `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`, then analyze `InterfacePortDispatchMetrics` alongside `DatabaseWriteBreakdown.InterfaceCallDurationMs` to confirm how much of the tail sits inside the UI path.
  - 2025-10-15 12:32 MT: Dispatcher telemetry run executed after clearing `Data/IngestionHistory`. Pipeline logs (`Logs/IngestionMetrics/2025-10-15.json`) show `DatabaseWriteBreakdown.InterfaceCallDurationMs` avg 1.31 s (p95 6.96 s, max 10.92 s) but no `InterfacePortDispatchMetrics` events-expected because the headless pipeline bypasses `MainWindow` dispatcher loops. `StreamDispatchDurationMs` in `InterfaceBulkInsertTiming` remains 0 ms across all batches. Next action: exercise the UI (e.g., launch StateTrace shell and load BOYO/WLLS) to capture real dispatcher metrics or craft a harness that pumps `DeviceRepositoryModule\Get-InterfacePortBatch` on the dispatcher thread.
  - 2025-10-15 12:45 MT: Planning the UI-driven telemetry capture. Will launch the WPF client, trigger device load for BOYO/WLLS so dispatcher batching runs, and note any harness changes needed to exercise `Get-InterfacePortBatch` in tests before executing the session.
  - 2025-10-15 13:02 MT: Attempted to launch `Main/MainWindow.ps1` from the shell; modules loaded and ingestion kicked off, but the command timed out before the WPF window could surface (headless agent session). No `InterfacePortDispatchMetrics` were emitted. Need either interactive UI access or a dispatcher harness that can invoke `Dispatcher.Invoke` without a visible window.
  - 2025-10-15 13:18 MT: Drafting a dispatcher harness plan-create `Tools/Invoke-InterfaceDispatchHarness.ps1` to stage interface rows, run the batching loop against `Dispatcher.CurrentDispatcher`, and emit `InterfacePortDispatchMetrics` without the WPF UI. Will implement and validate via telemetry before revisiting full UI interaction.
  - 2025-10-15 13:27 MT: Dispatcher harness implemented and validated. `Tools/Invoke-InterfaceDispatchHarness.ps1 -Hostname BOYO-A05-AS-05` emitted four `InterfacePortDispatchMetrics` events (DispatcherDurationMs avg 4.88 ms, max 17.55 ms; AppendDurationMs avg 0.65 ms). WLLS harness run (`-Hostname WLLS-A01-AS-01`) produced two events (DispatcherDurationMs avg 3.37 ms, max 6.20 ms; AppendDurationMs avg 0.95 ms). Telemetry appended to `Logs/IngestionMetrics/2025-10-15.json` (lines ~962-968). Next steps: integrate harness usage into perf notebook and compare against `InterfaceCallDurationMs` tail.
  - 2025-10-15 13:40 MT: Planning the telemetry correlation pass-document how we will read `InterfacePortDispatchMetrics` and `DatabaseWriteBreakdown.InterfaceCallDurationMs` from `Logs/IngestionMetrics/2025-10-15.json`, calculate per-host deltas, and note any assumptions about the headless harness before running the analysis.
  - 2025-10-15 13:55 MT: Correlation complete. Parsed `Logs/IngestionMetrics/2025-10-15.json` and matched dispatcher events to `InterfaceCallDurationMs`: BOYO-A05-AS-05 spends 2.30 s in the interface call with only 19.52 ms inside Dispatcher.Invoke (delta 2.28 s); WLLS-A01-AS-01 spends 10.9 s vs. 6.74 ms of dispatcher time (delta 10.91 s). Remaining latency sits upstream (queue preparation or waits before dispatch), so dispatcher loops are no longer the prime suspect.
  - 2025-10-15 14:05 MT: Planning the queue-prep investigation-outline metrics for `Set-InterfacePortStreamData` (queue build duration, wait between bulk commit completion and first dispatch), list telemetry gaps, and document assumptions before reviewing module code.
  - 2025-10-15 14:22 MT: Queue-prep review complete. `Set-InterfacePortStreamData` telemetry shows clone work ≤25 ms, but `Initialize-InterfacePortStream` still materialises every batch without emitting `QueueBuildDurationMs` or batch counters. Comparing `InterfaceBulkInsertTiming` to `DatabaseWriteBreakdown.InterfaceCallDurationMs` leaves ~9.1 s per heavy host unexplained (WLLS-A01-AS-01: 10.9 s call vs. 1.66 s measured), pointing to missing instrumentation around queue initialisation/diff. Next action: add telemetry for queue build and restore `InterfaceSyncTiming` events before optimising.
  - 2025-10-15 14:48 MT: Implemented queue instrumentation. `Initialize-InterfacePortStream` now records `QueueBuildDurationMs`/`QueueBuildDelayMs`, emits `InterfacePortQueueMetrics`, and exposes `Get-LastInterfacePortQueueMetrics`; DeviceRepository Pester suite updated and passing. Next step is to capture the new telemetry via dispatcher harness/UI replay and verify whether queue build time explains the InterfaceCall tail; also investigate why `InterfaceSyncTiming` events are absent in the 2025-10-15 logs.
  - 2025-10-15 15:12 MT: Planning follow-up investigation: review the 2025-10-15 ingestion telemetry and ParserPersistenceModule instrumentation to understand why  `InterfaceSyncTiming` events are missing, then outline any required fixes before touching code. 
  - 2025-10-15 15:12 MT: Planning telemetry validation: after confirming the  `InterfaceSyncTiming` emission path, run the dispatcher harness (and pipeline if needed) to capture `InterfacePortQueueMetrics` alongside restored `InterfaceSyncTiming` payloads. 
  - 2025-10-15 15:46 MT: Investigation confirms `InterfaceSyncTiming` is failing inside `ParserPersistenceModule.psm1:1297-1350` when strict mode encounters unset stream metrics (`$streamCloneDurationMs`, `$streamRowsReceived`, etc.). The queue instrumentation added earlier threads those fields into the payload, but `Update-InterfacesInDb` never initializes them, so the telemetry write throws and the catch block swallows the error. Next action: initialize the stream metrics from `$bulkMetrics` (defaulting to zero) before emitting telemetry and extend coverage so the failure reproduces in tests.
  - 2025-10-15 16:30 MT: Telemetry validation complete. Reran `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` after hydrating interface stream metrics in ParserPersistence; 37 `InterfaceSyncTiming` events landed with `StreamCloneDurationMs` averaging 22.2 ms (p95 53.7 ms) and `StreamDispatchDurationMs` averaging 34.2 ms (p95 64.1 ms). `StreamRowsCloned` stayed 0 across all hosts, demonstrating the zero-default path survives strict mode. Next action: fold these results into the consolidated plan and resume queue instrumentation follow-up on the `InterfaceCallDurationMs` tail.
  - 2025-10-15 16:45 MT: Queue harness telemetry captured. Executed `Tools/Invoke-InterfaceDispatchHarness.ps1` via Windows PowerShell for BOYO-A05-AS-05 and WLLS-A01-AS-01 (chunk size 24). `InterfacePortQueueMetrics` reports queue build durations 18.9-26.5 ms with delays <=103 ms while pipeline `DatabaseWriteBreakdown` still shows InterfaceCallDuration averaging 2.0 s (BOYO) to 10.5 s (WLLS). Confirms queue initialization is not the tail driver; need to scrutinize pre-dispatch wait states or DatabaseWriteBreakdown aggregation for the remaining >1 s gap.
  - 2025-10-16 10:25 MT: Reused per-host metadata and direct string casts inside `DeviceRepository\Get-InterfacesForSite` so projection work no longer re-parses site, zone, vendor, or building values per row. DeviceRepository/ParserPersistence Pester suites pass; schedule a fresh cold-shell pipeline to log the resulting `InterfaceSiteCacheMetrics` snapshot/materialize deltas.
  - 2025-10-16 11:10 MT: Reworked `DeviceRepository\Get-InterfaceSiteCache` to build typed `InterfaceCacheEntry` rows and reuse cached host dictionaries, eliminating per-row `PSObject` cloning during snapshot hydration. Re-ran `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` and `Modules/Tests/ParserPersistenceModule.Tests.ps1`; both remain green. Cold-shell pipeline (history reset, `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`) now records BOYO Hydration max 0.637 s / Snapshot 0.517 s / Materialize 0.213 s / Build 0.136 s and WLLS Hydration max 0.534 s / Snapshot 0.362 s / Materialize 0.173 s / Build 0.172 s in `Logs/IngestionMetrics/2025-10-16.json`; `DatabaseWriteBreakdown.SiteCacheFetchDurationMs` tops out at 0.698 s (BOYO-A05-AS-02) with WLLS <=0.536 s. Follow-up: profiling shows BOYO fetch averages 0.607 s with Query 0.105 s, Materialize 0.183 s (PortSort 0.086 s, Template 0.045 s, Object 0.023 s) plus a 0.15-0.25 s residual in `Get-InterfacesForSite` (likely list sort) and 0.114 s host-map build; WLLS mirrors the pattern (Query 0.017 s, Materialize 0.139 s, residual 0.13-0.17 s, Build 0.142 s). Next step is to instrument the sort/build loops and prototype pooling/presorted buffers to shave the remaining ~0.2 s.
  - 2025-10-16 12:35 MT: Validated the host-map/sort telemetry with a cold-shell pipeline replay (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`). `Logs/IngestionMetrics/2025-10-16.json` now shows BOYO hydration max 0.64 s (`HostMapDurationMs` 147 ms, `SortDurationMs` 45 ms) and WLLS 0.53 s (`HostMapDurationMs` 81 ms, `SortDurationMs` 59 ms), driving `DatabaseWriteBreakdown.InterfaceCallDurationMs` p95 down to 1.02 s (BOYO) / 0.44 s (WLLS). Next step: prototype host-map dictionary reuse or presorted buffers to reclaim the remaining ~150 ms snapshot cost before tuning materialize time.
  - 2025-10-16 12:52 MT: Planning to pool per-host dictionaries and cached `InterfaceCacheEntry` instances inside `DeviceRepository\Get-InterfaceSiteCache`, and to bypass the redundant `List.Sort` when the Access query already orders `Hostname, Port`. Goal: shave `HydrationHostMapDurationMs` toward sub-60 ms and collapse `HydrationSortDurationMs` without disturbing downstream signatures. Implementation queued after documentation primacy steps complete.
  - 2025-10-16 13:28 MT: Host-map pooling + cache signature reuse merged. Cold-shell replay shows BOYO `HydrationHostMapDurationMs` averaging 111 ms (`SnapshotDurationMs` 435 ms) and WLLS 58 ms (`SnapshotDurationMs` 292 ms) with `HydrationSortDurationMs` trimmed to 15-20 ms and `InterfaceCallDurationMs` p95 down to 0.92 s / 0.44 s. Follow-up: investigate the BOYO first-pass spike (signature mismatch path) to decide whether to seed cache entries pre-hydration or to document the warm-run expectation.
  - 2025-10-16 13:47 MT: Added host-map signature reuse counters ( `HostMapSignatureMatchCount`, `HostMapSignatureRewriteCount`, `HostMapEntryAllocationCount`, `HostMapEntryPoolReuseCount`) and reran the cold-shell pipeline after clearing ingestion history. First hydrations still rewrite the full cache (BOYO 0/636 matches, WLLS 0/1224), so next pass will drive a refresh hydration to confirm warm-run reuse before deciding on cache seeding vs. documenting the cold-start hit. 
  - 2025-10-15 17:05 MT: Added site-cache fetch/refresh timing to ParserPersistence telemetry and copied the fields into `DatabaseWriteBreakdown`. `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` passes with the new assertions. Latest pipeline run (post module reload) still shows InterfaceCallDurationMs >> queue metrics (BOYO-A05-AS-05 avg 2.02 s vs. queue build 24 ms / delay 65 ms; WLLS-A01-AS-01 avg 10.5 s vs. 18.9 ms / 94 ms). Need a clean dispatcher session or cold-shell pipeline to capture the new `SiteCacheFetchDurationMs` values-the harness runner keeps totals near-zero because the site cache is already primed.
  - 2025-10-15 17:20 MT: Ran `powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` from a fresh shell to record the cache timings. `Logs/IngestionMetrics/2025-10-15.json` now shows WLLS-A07-AS-07 with `SiteCacheFetchDurationMs` 14.50 s against `InterfaceCallDurationMs` 16.57 s (refresh stayed 0) while staging/stream metrics remained <100 ms. Confirms ~88% of the write latency tail comes from the site cache fetch; next step is to flush or instrument DeviceRepository cache hydration so other hosts surface their fetch costs and we can target that path.
  - 2025-10-15 17:35 MT: Instrumented DeviceRepository cache hydration (`Get-InterfaceSiteCache`) to capture `InterfaceSiteCacheMetrics` plus fetch/build breakdowns, surfaced the metadata via `SiteCacheFetchStatus`/`SiteCacheSnapshotDurationMs`/`SiteCacheBuildDurationMs`/`SiteCacheHostCount`, and refreshed DeviceRepository/ParserPersistence tests (both passing). Cold-shell pipeline rerun (logs reset) hit duplicate guard before hydration, so new fields/events did not land in `2025-10-15.json`; plan to clear `Data/IngestionHistory` on the next session to force a full cache hydrate and validate the metrics end to end.
  - 2025-10-15 18:05 MT: Cleared `Data/IngestionHistory` and reran `powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` from a cold shell. `Logs/IngestionMetrics/2025-10-15.json` now records `InterfaceSiteCacheMetrics` for BOYO (Hydration 4.913 s, Snapshot 2.849 s, Build 2.063 s across 12 hosts) and WLLS (Hydration 14.781 s, Snapshot 10.783 s, Build 3.998 s across 25 hosts). `DatabaseWriteBreakdown.SiteCacheFetchDurationMs` tracks the same story (BOYO p95 4.974 s, WLLS p95 14.497 s; max 14.790 s) confirming the InterfaceCall tail is bound by initial cache hydration. Next step is to profile `DeviceRepository\Get-InterfaceSiteCache` hydrate stages so we can shave down the 14–15 s WLLS fetch.
  - 2025-10-15 18:20 MT: Planning stage-level hydration telemetry: extend `DeviceRepository\Get-InterfaceSiteCache`/`Get-InterfacesForSite` to capture query provider, attempts, wait duration, template load, and materialize timings, surface the breakdown through `InterfaceSiteCacheMetrics`/`DatabaseWriteBreakdown`, and update unit specs before rerunning the cold-shell pipeline.
- 2025-10-15 18:45 MT: Stage-level telemetry captured after rerunning `powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`. `InterfaceSiteCacheMetrics` now reports BOYO `QueryDurationMs` 1.99 s (Execute 8 ms, Materialize 1.97 s, Template 95 ms, Build 1.91 s) and WLLS `QueryDurationMs` 7.10 s (Execute 46 ms, Materialize 3.05 s, Template 14 ms, Build 3.80 s) with zero exclusive retries. `DatabaseWriteBreakdown` surfaces the same fields per host (WLLS fetch slices <4 ms post-hydration). Next step: trace why ADODB recordset enumeration and host-map materialization consume 10+ s on WLLS-consider profiling the Access query pipeline or pre-sizing host maps before projecting interface objects.
- 2025-10-15 19:35 MT: Enumerations reworked (recordset `GetRows`) plus host-map property lookups finished and validated with a cold-shell pipeline (`powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` after clearing `Data/IngestionHistory`). Latest `InterfaceSiteCacheMetrics` show WLLS Hydration 7.03 s (Query 0.116 s down from 7.10 s, Materialize 3.43 s, Build 1.61 s down from 3.80 s, Snapshot 5.42 s) and BOYO Hydration 0.67 s (Query 0.028 s vs. 1.99 s, Materialize 0.30 s vs. 1.97 s, Build 0.15 s vs. 1.91 s). `DatabaseWriteBreakdown.SiteCacheFetchDurationMs` now tops out at 3.7 ms (previously 14.5 s), but `InterfaceCallDurationMs` still sits at 8-9.9 s because `SnapshotDurationMs` + `MaterializeDurationMs` dominate the refreshed runs. Next actions: profile the materialize path (PortSort key generation, template lookups, PSCustomObject allocation) and explore batching snapshot projections to trim the remaining ~3.4 s materialize cost.
  - 2025-10-15 20:05 MT: Materialize instrumentation landed. Fresh cold-shell pipeline (history reset) shows BOYO `SiteCacheMaterializePortSortDurationMs` averaging 0.24 s (projection 14.6 ms, template 12.6 ms, object build 36.3 ms; total materialize 0.68 s) while WLLS averages 3.01 s port-sort, 56.8 ms projection, 110 ms template resolution, and 452 ms PSCustomObject allocation (total materialize 2.70 s with `SnapshotDurationMs` 7.28 s). PortSort dominates the remaining hydrate cost; next steps are to benchmark `InterfaceModule\Get-PortSortKey`, cache per-vendor template lookups, and pre-allocate host collections to shave the 3.0 s port-sort tail.
  - 2025-10-15 16:20 MT: Port-sort caching + pre-sized materialize collections landed. Cold-shell pipeline rerun (history reset, `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`) drops BOYO `SiteCacheMaterializePortSortDurationMs` average to 0.30 s (p95 0.37 s) and WLLS to 1.94 s (p95 3.01 s) while cache telemetry reports ~6.5k hits / 1.1k misses for BOYO (cache ≈96) and ~29.4k hits / 1.2k misses for WLLS (cache ≈144). Remaining tail sits in WLLS template/object materialize slices; next investigation targets those phases.
  - 2025-10-16 13:55 MT: Warm-run telemetry attempt (same-session `Invoke-StateTraceParsing -Synchronous` replay after manual cache refresh) still produced `SiteCacheFetchStatus`=`Refreshed` for every host with zero `SiteCacheHostMapSignatureMatchCount`. `Logs/IngestionMetrics/2025-10-16.json` shows BOYO rewrote 3,240 entries (2,700 pool reuses / 540 allocations, avg fetch 2.23 ms, max 17.21 ms) and WLLS rewrote 13,128 (11,928 reuses / 1,200 allocations, avg fetch 0.80 ms, max 1.69 ms). Need to dig into why `ParserPersistenceModule` keeps missing cached host maps between runs before documenting warm-run expectations.
  - 2025-10-16 14:25 MT: ParserPersistence now emits `SiteCacheResolveInitial*` and `SiteCacheResolveRefresh*` telemetry so DatabaseWriteBreakdown can show why each hydration fell back to refresh. Follow-up: rerun a warm run without `-Refresh` to capture the new statuses and key samples, then decide whether the cache misses come from host-key mismatches, stale cache age, or explicit clears.
  - 2025-10-16 14:50 MT: Warm-run replay (renamed `Data/IngestionHistory/*.json` between passes to reprocess the corpus without touching site caches) reports `SiteCacheResolveInitialStatus=ExactMatch` / `SiteCacheResolveRefreshStatus=NotAttempted` for every host. 35/37 fetches now surface `CacheStatus=Hit` with fetch averages 1.36 ms (BOYO, max 9.35 ms) and 0.43 ms (WLLS, max 0.45 ms), but BOYO-A05-AS-02 (734.68 ms) and WLLS-A01-AS-01 (557.40 ms) still log `CacheStatus=Hydrated` despite the resolve hit. Host-map counters remain 0 signature matches versus 38,232 rewrites/allocations. Action: inspect `DeviceRepository\Get-InterfaceSiteCache` first-host hydration flow and the signature comparison path to understand why host maps never register matches even on back-to-back runs.
  - 2025-10-16 21:12 MT: Refactored `DeviceRepository\Get-InterfaceSiteCache` to stage previous host/port dictionaries before clearing so refresh hydrations reuse typed entries and start incrementing `HydrationHostMapSignatureMatchCount`. Added unit coverage (`It "reuses cached host entries when refresh sees unchanged data"`) and DeviceRepository Pester passes. Next: rerun the warm-run pipeline (no `-Refresh`) to confirm telemetry now reports signature matches and to verify whether the first host per site still hydrates.
  - 2025-10-16 21:40 MT: Warm-run replay (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing`, ingestion history left intact) still shows 35/37 `DatabaseWriteBreakdown.SiteCacheFetchStatus=Hit`, yet `SiteCacheHostMapSignatureMatchCount` remains 0 while rewrites total 7,632 (BOYO) and 30,600 (WLLS) with zero pool reuse. First hosts BOYO-A05-AS-02 and WLLS-A01-AS-01 continue to hydrate (fetch 0.554 s / 0.325 s) even though `SiteCacheResolveInitialStatus=ExactMatch`. Need instrumentation around the `$hostMap.TryGetValue` + signature comparison branch to surface why every port is treated as a rewrite before deciding on cache seeding guidance.
  - 2025-10-16 22:05 MT: Plumbed the host-map reuse counters through ParserPersistence/DeviceLogParser, cleaned duplicate payload fields, and reran `Invoke-Pester` (DeviceRepository + ParserPersistence suites). Warm-run telemetry from `Logs/IngestionMetrics/2025-10-16.json` (`2025-10-16T15:48:25.376-06:00`) now carries `HostMapCandidate*` metrics, but WLLS still reports `HostMapSignatureMatchCount=0` vs. `HostMapSignatureRewriteCount=1224`, `HostMapCandidateMissingCount=1224`, and `HostMapLookupMissCount=25` with `HydrationDurationMs=937.09`. Matching `DatabaseWriteBreakdown` events expose the same zero-match story, so the instrumentation is in place while the reuse logic continues to rewrite. Follow-up: add logging around the reuse/signature branch (and signature persistence in `Set-InterfaceSiteCacheHost`) to see what signatures are being compared before attempting further cache seeding guidance.
  - 2025-10-16 22:40 MT: Instrumented mismatch sampling (`HydrationHostMapSignatureMismatchSamples`) in DeviceRepository and threaded the samples through ParserPersistence/DeviceLogParser so telemetry now captures the first five `Hostname`/`Port` pairs with previous/new signatures when a reused entry rewrites. Updated DeviceRepository/ParserPersistence tests to assert the new fields. Follow-up: run the warm-run pipeline (no `-Refresh`) to collect the new sample data for WLLS and inspect whether signatures are being truncated, re-normalized, or stripped before reuse.
- 2025-10-16 22:55 MT: Warm-run replay confirms the new `*SignatureMismatchSamples` arrays stay empty because every rewrite still increments `HostMapCandidateMissingCount` (no reuse candidates recovered). Next objective: extend instrumentation for the candidate-missing path-log which host/port keys fail reuse or capture the cached `Signature` values in `Set-InterfaceSiteCacheHost`-so we can see why the previous host map never contributes entries.
- 2025-10-21 09:22 MT: Warm-run pipeline (ingestion history renamed, no `-Refresh`) produced `InterfaceSiteCacheMetrics` with `CacheStatus=Hydrated`, `HostMapCandidateMissingCount=636 (BOYO)` / `1224 (WLLS)`, and the new `HostMapCandidateMissingSamples` all report `Reason=HostSnapshotMissing` for the first host (`BOYO-A05-AS-02`, `WLLS-A01-AS-01`). `DatabaseWriteBreakdown` shows `SiteCacheFetchStatus=Hit` but `SiteCacheHostMapSignatureMatchCount=0`, confirming cache resolve hits still fall back to full hydrations. Action: probe `Set-InterfaceSiteCacheHost` and the signature cache restore logic to see why prior host dictionaries disappear between runs and whether we need to persist the snapshot differently.
- 2025-10-21 09:58 MT: `Set-InterfaceSiteCacheHost` now writes typed `InterfaceCacheEntry` objects and `Get-InterfaceSiteCache` converts any legacy PSCustomObject cache rows via `ConvertTo-InterfaceCacheEntryObject`. Added a warm-run regression test plus refreshed ParserPersistence coverage; targeted `Invoke-Pester` runs pass. Sequential warm-run replay (history renamed, two pipeline passes in one process) still reports `HostMapSignatureMatchCount=0` / `HostMapCandidateMissingCount=636/1224`, so cached rows are not reused ahead of hydration. Next: inspect the cache resolve flow in `ParserPersistenceModule`/`DeviceRepositoryModule` to learn why host maps remain undiscovered before closing the reuse task.
- 2025-10-23 19:11 MT: Updated `Collect-TelemetryForPass` to drop pre-baseline telemetry during fallback and wired the warm-run regression wrapper to run cold passes against empty ingestion history while `WarmBackup` falls back to the cold snapshot. `Tools\Invoke-StateTraceVerification.ps1 -SkipTests -VerboseParsing` now passes with cold `InterfaceCallDurationMs` avg 938.038 ms (37 hosts; `Provider=ADODB` for 2, `Cache` for 35) versus warm 763.926 ms (37 hosts, `Provider=Cache`), yielding a 174.112 ms / 18.56% gain and 100% warm cache hit ratio. Follow-up: investigate the two cold-pass cache hits so the baseline reverts to full hydrations and the warm delta approaches the earlier ~60% target.
  - 2025-10-21 10:35 MT: Extended cache telemetry with `HydrationPreviousHostCount`, `HydrationPreviousPortCount`, and `HydrationPreviousHostSample`, then reloaded modules and ran `powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing`. Latest WLLS run (`Logs/IngestionMetrics/2025-10-21.json` @ `10:25:31.289-06:00`) still shows `CacheStatus=Hydrated`, `HostMapSignatureMatchCount=0`, `HostMapCandidateMissingCount=1224`, and the new counters at `PreviousHostCount=0`, `PreviousPortCount=0`, `PreviousHostSample=''`. Cached host dictionaries remain empty at hydration time despite `SiteCacheResolveInitialStatus=ExactMatch`; next action is to trace how `Set-InterfaceSiteCacheHost` repopulates `SiteInterfaceSignatureCache` after each host so we can capture where entries are cleared before reuse.
  - 2025-10-22 15:34 MT: Migrated the shared site cache to an AppDomain-level concurrent dictionary (`Initialize-SharedSiteInterfaceCacheStore`, `Get-SharedSiteInterfaceCacheStore`) and refreshed cross-runspace regression coverage. Cold-pass workers now log `InterfaceSiteCacheSharedStore` `Set` events (`EntryCount=1` for BOYO, `EntryCount=2` for WLLS), but preserved warm passes still emit `GetMiss` telemetry and hydrate via ADODB after the helper applies single-thread overrides (pool reset). Follow-up: keep parser configuration stable across passes or reseed the AppDomain store post-reset so warm runs report non-zero `HostMapSignatureMatchCount`.
- 2025-10-21 11:12 MT: Added snapshot diagnostics (`HydrationPreviousSnapshotStatus`, host-map type/count, exception text) to `DeviceRepository\Get-InterfaceSiteCache` and surfaced them through ParserPersistence telemetry. Once the warm-run pipeline is rerun these fields should confirm whether cache reuse fails because the prior host map is missing, unsupported, or throwing conversion errors. Follow-up: execute the warm run without `-Refresh` and record the new metrics in `Logs/IngestionMetrics`.
- 2025-10-21 10:56 MT: Warm-run pipeline replay (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing`, no `-Refresh`) after the new telemetry recorded WLLS with `SiteCacheFetchStatus=Hydrated`, `SiteCacheResolveInitialStatus=ExactMatch`, yet `SiteCachePreviousSnapshotStatus=CacheEntryMissing`, `SiteCacheHostMapSignatureMatchCount=0`, `SiteCacheHostMapSignatureRewriteCount=1224`, and `SiteCacheHostMapCandidateMissingCount=1224` (`Logs/IngestionMetrics/2025-10-21.json`, `Timestamp=10:53:11 MT`). BOYO counters remain at the earlier 09:54 capture, implying this cycle only hydrated WLLS. Action: trace the WLLS cache resolve/write path in `ParserPersistenceModule` and `DeviceRepositoryModule` to learn why the stored host map is missing despite an exact key hit, and confirm the warm-run queue is still presenting BOYO hosts.
- 2025-10-21 11:57 MT: Implemented `-PreserveModuleSession` on `Tools/Invoke-StateTracePipeline.ps1` so warm-run exercises keep module caches alive. Running two in-process passes (ingestion history reset between runs) now yields `Logs/IngestionMetrics/2025-10-21.json` entry `11:56:43.061-06:00` with `SiteCacheFetchStatus=Refreshed`, `Provider=Cache`, `SiteCacheHostMapSignatureMatchCount=1224`, `SiteCacheHostMapCandidateMissingCount=0`, and `SiteCachePreviousSnapshotStatus=Converted`, confirming host dictionaries persist when modules stay loaded. Follow-up: decide whether the harness should default to preserving modules for diagnostics or document the new switch in the operator runbook/task checklists.
- 2025-10-21 13:22 MT: Logged the `-PreserveModuleSession` guidance in the operator runbook and linked the checklist updates here. Leaving the harness default unchanged keeps cold-shell regressions visible; operators should invoke `Tools/Invoke-StateTracePipeline.ps1 -PreserveModuleSession` during cache reuse telemetry sweeps and record the resulting `HostMapSignatureMatchCount`/`HydrationDurationMs` trends. Next action: gather operator feedback during the next BOYO/WLLS validation window to decide whether the switch should graduate into the standard telemetry workflow.
- 2025-10-21 14:10 MT: Added `Tools/Invoke-WarmRunTelemetry.ps1` to script preserved-session cold/warm passes and surface `InterfaceSiteCacheMetrics` deltas without manual harness juggling. First automation run (`-ColdHistorySeed Empty -WarmHistorySeed Snapshot`) confirmed cold-pass timings (BOYO 649 ms, WLLS 664 ms) but the warm pass still skipped cache metrics (`HostMapSignatureMatchCount` stayed 0). Follow-up: adjust ingestion-history seed strategy (or detect/repair pipeline cache bypass) so automated warm passes report `Provider=Cache` before rolling the script into the standing telemetry workflow.
- 2025-10-21 14:38 MT: Captured the post-cold ingestion snapshot inside `Tools/Invoke-WarmRunTelemetry.ps1` so preserved warm passes reuse the cold-pass history. Replayed the automation (`-ColdHistorySeed Snapshot`, `-ColdHistorySeed Empty -WarmHistorySeed Snapshot`, `-ColdHistorySeed Empty -WarmHistorySeed Empty`); cold passes behaved as expected, but every warm pass still emitted zero `InterfaceSiteCacheMetrics`; `Logs/IngestionMetrics/2025-10-21.json` @ 14:30:58-14:30:59 MT only logs `SkippedDuplicate` events. Next step: instrument the preserved-session pipeline path to prove DeviceRepository emits cache-hit telemetry (or pinpoint where cached host maps are dropped) before promoting the script to operators.
- 2025-10-21 15:06 MT: DeviceRepository cache hits now emit `InterfaceSiteCacheMetrics` via a new `Publish-InterfaceSiteCacheTelemetry` helper (hydration path updated to reuse it). `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` passes. Warm-run automation still produces only `SkippedDuplicate` events because the preserved warm pass loads the post-cold ingestion snapshot; adjust the warm seed (or cache-bypass logic) so the second pass actually exercises `Get-InterfaceSiteCache` and surfaces the new cache-hit telemetry before rolling the script out.
- 2025-10-21 19:54 MT: `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches` now drives cache-hit telemetry between passes (`InterfaceSiteCacheMetrics` reports `CacheStatus=Refreshed`, `Provider=Cache`, `HostMapSignatureMatchCount=1224`, and `HydrationDurationMs` ~0.23 s in `Logs/IngestionMetrics/2025-10-21.json` 19:54 MT). Updated the operator runbook/task guidance to cover the new switch plus a reminder to prune `.warmrun.*.bak` history backups after reviews; gather operator feedback during the next validation window and revise the helper if additional automation (for example, default JSON exports) would help.
- 2025-10-22 10:05 MT: Hooked a cache probe into `Tools/Invoke-WarmRunTelemetry.ps1` (calls `Get-InterfaceSiteCache -Site` after refresh) and reran `-VerboseParsing -RefreshSiteCaches`. The probe surfaced no telemetry (likely `Write-StTelemetryEvent` suppression or cache reset), and the warm pass still hydrates from ADODB (`HostMapSignatureMatchCount=0`, `PreviousSnapshotStatus=CacheEntryMissing`, BOYO Hydration 616 ms / WLLS 548 ms). Next: trace DeviceRepository cache state immediately after the scripted refresh to confirm whether cached host maps survive, and verify whether telemetry hooks fire outside the pipeline harness.
  - 2025-10-22 10:38 MT: Added `Get-SiteCacheState` logging to the helper; the post-refresh and pre-warm snapshots both reported zero cached hosts/rows (console output `Cache state entries after refresh: 0` / `before warm pass: 0`). `Logs/IngestionMetrics/WarmRunTelemetry-latest.json` still lacks `Provider=Cache` events. Next up: inspect the in-session cache directly (module invoke against `$script:SiteInterfaceSignatureCache`) and review pipeline module-import logic for unintended cache clears.
  - 2025-10-22 11:20 MT: ParserRunspaceModule now preserves the runspace pool (new `Reset-DeviceParseRunspacePool`, `Invoke-InterfaceSiteCacheWarmup`), and both the pipeline harness and warm-run helper pass `-PreserveRunspace`. Warm-run automation throttles to single-thread overrides and seeds caches through the preserved pool, yet `Logs/IngestionMetrics/WarmRunTelemetry-latest.json` still shows warm passes hydrating from ADODB (`Provider=ADODB`, `HostMapSignatureMatchCount=0`, `HydrationDurationMs` ≈0.57 s). Follow-up: trace worker runspace affinity—caches may live per runspace, so preserved pools need deterministic site-to-runspace mapping before reuse registers.
- 2025-10-22 09:58 MT: Automated run (`Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-latest.json`) still shows warm-pass hydrations hitting ADODB (`CacheStatus=Hydrated/Hit`, `HostMapSignatureMatchCount=0`, `PreviousSnapshotStatus=CacheEntryMissing`). Need to trace why the helper’s refresh stage fails to persist host maps before the warm pass—suspect the pipeline invocation is clearing caches or the refresh step is skipping telemetry. Next action: instrument the refresh helper to verify telemetry capture and inspect `DeviceRepositoryModule` cache state immediately before the warm invocation.
  - 2025-10-22 11:45 MT: Added DeviceRepository cache summary helper and ParserRunspace runspace telemetry (InterfaceSiteCacheRunspaceState). Latest helper run confirms cold-pass workers start with empty caches (CacheExists=false), warm-pass workers see populated host maps (CacheStatus=Hydrated), yet warm telemetry still shows Provider=ADODB / HostMapSignatureMatchCount=0 (Logs/IngestionMetrics/2025-10-22.json:6257, :6814). Follow-up: investigate the candidate-missing branch that forces hydrations despite cached signatures and understand why the scripted refresh does not emit Warmup* runspace events.
  - 2025-10-22 13:40 MT: Added a shared site-interface cache store in DeviceRepositoryModule and regression coverage for cross-runspace cache hits. Warm-run automation still reports HostMapSignatureMatchCount=0 because [StateTrace.Repository.SharedSiteInterfaceCacheStore]::SiteCache remains empty after pipeline passes; next step is to confirm worker runspaces execute Set-SharedSiteInterfaceCacheEntry (inspect ParserRunspaceModule
device import flow) before re-running the preserved-session helper.
  - 2025-10-22 14:13 MT: Instrumented the shared cache helpers to emit `InterfaceSiteCacheSharedStore` telemetry. Cold-pass workers (RunspaceId `94780137-574d-4262-9fe8-41f2179546fb`) record `Set` events with entry counts 1-2, but the preserved warm pass (RunspaceId `2767d60f-a6ab-425b-8ff4-1150d6f2ade0`) only logs `GetMiss` with `EntryCount=0/1` before hydrating from ADODB (`Logs/IngestionMetrics/2025-10-22.json`). Conclusion: the static dictionary remains runspace-local. Next: move the shared store initialization outside worker creation or marshal hydrated entries back into the preserved pool so warm runs register cache hits.
  - 2025-10-22 15:58 MT: Warm-run helper now applies the single-thread overrides before the cold pass so preserved sessions reuse the same runspace config, but warm-run telemetry still reports Provider=ADODB with HostMapSignatureMatchCount=0 for BOYO/WLLS (Logs/IngestionMetrics/WarmRunTelemetry-latest.json ~15:54 MT). Next action: instrument DeviceRepositoryModule\Get-SharedSiteInterfaceCacheEntry (and parser worker usage) to learn why shared-store lookups return GetMiss ahead of warm hydrations.
- 2025-10-22 16:32 MT: Shared-store telemetry now captures AppDomain, process, thread, and store-hash identifiers. Preserved warm runs (Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches, ~16:25 MT) show cold and warm passes executing in AppDomain 1 with a stable store hash (StoreHashCode=61268168), yet each warm pass still emits GetMiss with EntryCount resetting to 0/1 before hydration (Logs/IngestionMetrics/2025-10-22.json lines ~17240-18480). No ParserRunspacePoolState events fired because the pipeline continues down the synchronous worker path. Next: trace Set-SharedSiteInterfaceCacheEntry / Get-InterfaceSiteCache removal points to learn which caller clears the shared dictionary between passes and why HostMapSignatureMatchCount remains zero.
- 2025-10-22 19:55 MT: Process-wide holder (`StateTrace.Repository.SharedSiteInterfaceCacheHolder`) now backs `Initialize-SharedSiteInterfaceCacheStore`, `Clear-SiteInterfaceCache` aligns the holder/AppDomain slot, and DeviceRepositoryModule tests cover the AppDomain reset path. Warm-run helper still hydrates via ADODB (`Provider=ADODB`, `HostMapSignatureMatchCount=0`) and shared-store telemetry logs `InitNewStore` for the warm worker (RunspaceId `e0fc37df-5a2b-4bd6-ac28-3fb9e143e5b5`, `StoreHashCode=19434694`). Next step: pinpoint why new worker runspaces miss the holder (likely per-runspace type load) and patch adoption so preserved sessions finally report `Provider=Cache` with signature matches.
  - 2025-10-23 10:19 MT: Warm-run helper now snapshots shared-cache entries after the cold pass and attempts to restore them before the warm run ( `SharedCacheSnapshot:*`, `SharedCacheRestore:PreWarmPass` in Logs/IngestionMetrics/WarmRunTelemetry-latest.json). Latest automation still captures `EntryCount=0` / `RestoredCount=0`, and warm telemetry continues to report `Provider=ADODB`, `HostMapSignatureMatchCount=0`, `HostMapSignatureRewriteCount=1224` for WLLS (Logs/IngestionMetrics/2025-10-23.json). Action: inspect `Initialize-SharedSiteInterfaceCacheStore`/`Set-SharedSiteInterfaceCacheEntry` inside worker runspaces to confirm the AppDomain store is populated or re-home the snapshot/restore logic into the preserved runspace so warm passes receive seeded host dictionaries. 
  - 2025-10-23 11:40 MT: New \\InterfaceSiteCacheReuseState\\ telemetry confirms cached host dictionaries persist (WLLS host count 25, total rows 1,224) but ParserPersistence still reports 1,224 host-map rewrites. Next: instrument the resolve path to understand why cached entries do not satisfy the candidate lookup.
