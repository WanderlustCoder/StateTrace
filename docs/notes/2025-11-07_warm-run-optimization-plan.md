# Warm Run Optimization Plan - 2025-11-07

## Current Baseline
- Latest preserved-session run (`Logs/\IngestionMetrics/\WarmRunTelemetry-20251107-runB.json`) shows cold avg 883.4 ms vs. warm 649.2 ms (26.5% / 234.2 ms gain).
- Weighted cache hits improved to 93.04% after host-count weighting, but raw DatabaseWriteBreakdown hit ratio is still 32.18% (84 hits / 177 misses).
- WLLS hosts dominate the miss pool: 50 hits vs. 72 refreshes plus 3 unknowns; Access diff/load times consume >400 ms per host based on `DatabaseWriteBreakdown` entries.

## Objectives
1. Lift warm-run InterfaceCall improvement to ≥60% (target warm avg ≤350 ms).
2. Maintain weighted cache hit ratio ≥90% and push raw DB-level hit ratio above 70% by ensuring every host writes its cache during the cold pass.

## Proposed Actions
1. **Expand Shared Snapshot Coverage**
   - Merge mock corpora using `Tools/Expand-MockLogCorpus.ps1 -SourceMetricsPath Logs/2025-11-06.json -Force` to synthesize logs for missing WLLS hosts, then rerun `Tools/Invoke-SharedCacheWarmup.ps1`.
   - Import latest production `SharedCacheSnapshot-*.clixml` into `Logs/SharedCacheSnapshot/` when available; accompany with `Inspect-SharedCacheSnapshot.ps1 -ListHosts` to verify ≥60 WLLS entries.

2. **Reduce Access Diff/Load Cost**
   - Instrument `ParserPersistenceModule` diff path with `DiffHotPathDurationMs` and `LoadExistingRowSetCount` to isolate the 400+ ms tail (use host weighting to prioritize WLLS-A05 cohort).
   - Prototype a keyed existing-row cache: hydrate per-site once per warm pass, keyed by `(Site, Hostname)`, so repeated warm hosts don't requery Access even when site caches are skipped.

3. **Pipeline Guardrails**
   - Update CI harness to treat `WarmCacheHitRatioPercentRaw < 70` or `WarmInterfaceCallAvgMs >= Cold` as failures, ensuring snapshot regressions surface immediately.

## Open Questions
- Do we maintain `SkipSiteCacheUpdate=true` in production, or can we flip it during cold passes to keep site caches fresh without touching Access writes?
- Is there a smaller BOYO/WLLS subset we can prioritize for warm-run validation to reduce run time while hitting the 60% target?

## 2025-11-08 Updates
- ParserPersistence now records `DiffComparisonDurationMs` (total time spent comparing incoming vs. existing rows) and `LoadExistingRowSetCount` (rows pulled from Access/site cache) inside each `InterfaceSyncTiming` event. `Tools/DeviceLogParser` forwards both fields into `DatabaseWriteBreakdown`, so warm-run telemetry can rank the heaviest diff/hydration hosts before we prototype the keyed existing-row cache.

## 2025-11-09 Run Summary
- `Tools/Invoke-WarmRunTelemetry.ps1 -ResetExtractedLogs -ColdHistorySeed Empty -WarmHistorySeed ColdOutput -RefreshSiteCaches -AssertWarmCache:$false -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-20251108-run3.json`
  - Cold vs. warm averages: `ColdInterfaceCallAvgMs=850.19 ms`, `WarmInterfaceCallAvgMs=851.64 ms` (`-0.17%` improvement, effectively flat).
  - Weighted cache hits stay high (`WarmCacheHitRatioPercent=90.54%`) because the shared snapshot serves every host, but `WarmCacheHitRatioPercentRaw=0%` since `SkipSiteCacheUpdate` prevents per-host DatabaseWriteBreakdown hits.
  - `DiffComparisonDurationMs` and `LoadExistingRowSetCount` now populate the per-host records; next action is to mine those values for the WLLS tail and prototype the keyed existing-row cache (or temporarily re-enable site-cache updates during the cold pass) so the raw DB hit ratio becomes meaningful again.
- Added `Tools/Analyze-WarmRunDiffHotspots.ps1` to slice the preserved-session JSON directly. Run `pwsh -File Tools\Analyze-WarmRunDiffHotspots.ps1 -TelemetryPath Logs\IngestionMetrics\WarmRunTelemetry-20251108-run3.json -Top 25 -OutputPath Logs\IngestionMetrics\WarmRunDiffHotspots.csv` to see the heaviest hosts before prioritizing Access/diff fixes.

## 2025-11-10 Updates
- Implemented the keyed existing-row cache prototype inside `Modules/ParserPersistenceModule.psm1` by backing `SiteExistingRowCache` with a cross-runspace `ConcurrentDictionary` (holder class + helper functions). Hosts processed with `SkipSiteCacheUpdate=$true` now hydrate each site once per parser session and reuse the cached dictionaries even when a different runspace picks up the warm pass.
- Added Pester coverage in `Modules/Tests/ParserPersistenceModule.Tests.ps1` to simulate a second parser worker attaching after the first hydration; the test asserts the follow-on host run no longer issues an Access `SELECT` when the shared cache is populated.
- Pending validation: rerun `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` followed by the preserved-session harness so `Logs/IngestionMetrics/20YY-MM-DD.json` captures `SiteCacheProvider=Cache` for >70% of hosts while `WarmRunTelemetry-*.json` records a >60% InterfaceCall improvement. Update this plan with the new raw hit/miss counts once the telemetry lands.
- 2025-11-10 10:50 MT: Cold pipeline rerun (`Logs/IngestionMetrics/2025-11-10.json`, latest timestamp) shows `SiteCacheProvider=Cache` on 24/230 InterfaceSyncTiming events with `SiteCacheExistingRowSource='SiteExistingCache'`, confirming the keyed cache is feeding parser workers. However, DatabaseWriteBreakdown still records 0 cache providers because the Access write path sets `SkipSiteCacheUpdate` before the telemetry is emitted. The paired warm regression (`Logs/IngestionMetrics/WarmRunTelemetry-20251110-run2.json` with `-AssertWarmCache:$false`) reports `ColdInterfaceCallAvgMs=722.585 ms`, `WarmInterfaceCallAvgMs=733.916 ms` (-1.57% regression) and `WarmCacheHitRatioPercentRaw=0%` despite `WarmCacheHitRatioPercent=91.3%`. Action: thread the new provider reason (`SiteExistingCache`) into DatabaseWriteBreakdown so raw hits can be counted, then re-run the warm regression to confirm the ≥70% raw hit target.
- 2025-11-10 12:05 MT: DeviceLogParser instrumentation (`Resolve-DatabaseWriteBreakdownCacheProvider`) and tests landed, then `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` plus the preserved-session harness were re-run with `SkipSiteCacheUpdate` preserved. The harness still fails the raw-hit guard when assertions are enabled (`warmrun-error-20251110-115325.txt` shows 404 provider misses, 430 signature-match misses, and warm InterfaceCall averages higher than cold). A non-asserting telemetry export (`Logs/IngestionMetrics/WarmRunTelemetry-20251110-120255.json`) captured the regression for analysis: `ColdInterfaceCallAvgMs=558.716 ms`, `WarmInterfaceCallAvgMs=589.853 ms` (-5.57%), `WarmCacheHitRatioPercentRaw=0%`, weighted hits 90.37%. DatabaseWriteBreakdown records continue to log `SiteCacheExistingRowSource='DatabaseQuery'`, so the new provider tagging never fires. Next step: investigate why the keyed existing-row cache is not yielding `SiteExistingCache` sources during the warm pass even with `SkipSiteCacheUpdate` enabled so the raw guard can trip.
- 2025-11-10 13:30 MT: Instrumented `SiteExistingRowCacheState` events are landing (`Logs/IngestionMetrics/2025-11-10.json` now contains 194 records). Only 22 events report `SiteExistingRowSource='SiteExistingCache'`; the remaining 172 are still `DatabaseQuery`, even though 180/194 events have `CacheEnabled=true`. All cache hits come from the duplicate `SW1` / `WLLS-A01-AS-0{1,2}` hosts, which we ingest multiple times during synthetic runs. BOYO/WLLS cohorts do populate the per-site dictionary (`SiteHostEntryCount` climbs into double digits) but every new host still pays an Access SELECT because the keyed cache is host-local rather than site-wide. Warm-run harness with `-PreserveSkipSiteCacheSetting` still fails (`warmrun-error-current.txt`: `ColdInterfaceCallAvgMs=504.102 ms`, `WarmInterfaceCallAvgMs=524.172 ms`, 507 warm hosts without `SiteCacheProvider=Cache`, 645 hosts without signature matches). Next action: decide whether to hydrate entire sites (shared row dictionaries keyed by `(Site,Host)`) ahead of the warm pass or pre-load Access data via `DeviceRepositoryModule\Get-InterfaceSiteCache` so we can reuse the cached host maps across cold→warm runs and finally raise the raw hit ratio above 70%.
- 2025-11-10 13:10 MT: ParserPersistence now treats `STATETRACE_SKIP_SITECACHE_UPDATE=1` the same as the module flag so every worker runspace honors skip mode, and it emits a new `SiteExistingRowCacheState` telemetry event whenever the keyed cache is enabled (includes site, host, hit/miss, host-entry counts). Added Pester coverage for the env-only scenario. Next action: run the preserved-session harness again and inspect the new telemetry to see whether the runspace workers ever hydrate the keyed cache; if the event indicates `SiteHostEntryCount=0` after a cold pass, wire up ParserWorker to call `Set-ParserSkipSiteCacheUpdate` inside each worker runspace or propagate the keyed cache holder through the preserved runspace pool.
- 2025-11-10 14:10 MT: Warm-run harness now exports `SiteExistingRowCacheSnapshot-*.clixml` after the cold pass and restores it before the warm pass (`STATETRACE_SITE_EXISTING_ROW_CACHE_SNAPSHOT` is set and ParserWorker runspaces call `ParserPersistenceModule\Import-SiteExistingRowCacheSnapshotFromEnv` during module init). `Logs/IngestionMetrics/2025-11-10.json` shows 421 cache-state events (34 hits, 387 misses) and the snapshot weighs ~2.7 MB. Even with the snapshot restored, preserved warm runs still fail (`warmrun-error-20251110-140820.txt`: `ColdInterfaceCallAvgMs=447.128 ms`, `WarmInterfaceCallAvgMs=459.877 ms`, 563 providers reported as non-cache, 817 hosts without signature matches) because BOYO/WLLS hosts only appear once per run; we still need a site-wide hydration pass (preloading each site's host dictionary or seeding DeviceRepository's shared cache) so first-touch hosts can read from the snapshot without issuing an Access `SELECT`.
- 2025-11-10 14:55 MT: ParserPersistence now primes each site entry with a snapshot copy (`PrimedEntries`) and rehydrates host dictionaries before `Update-InterfacesInDb` touches Access; DatabaseWriteBreakdown also inspects the latest telemetry to tag `SiteCacheProvider=Cache`/`SiteCacheFetchStatus=Hit` whenever `SiteCacheExistingRowSource=SiteExistingCache`. Targeted Pester coverage landed for both modules. A fresh `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` + `Tools/Invoke-WarmRunTelemetry.ps1 -ResetExtractedLogs -ColdHistorySeed Empty -WarmHistorySeed ColdOutput -RefreshSiteCaches -AssertWarmCache -PreserveSkipSiteCacheSetting` run still surfaces the shared-cache warnings (“Shared cache snapshot contained no valid site entries… none were restored before the warm pass”), and the harness never emits a new `WarmRunTelemetry-*.json`. The latest cold telemetry (`Logs/IngestionMetrics/2025-11-10.json`) now includes 1,160 `InterfaceSyncTiming` rows but only 74 report `SiteCacheExistingRowSource='SiteExistingCache'` (≈6.4%), and `SiteExistingRowCacheState` hits remain at 7.9% (41/519). Next steps: trace why `Restore-SharedCacheEntries` reports empty snapshots (only 1 entry captured after refresh) and ensure the per-site primed dictionaries are actually repopulated inside the preserved worker pool so raw DB hits can move off the current 0–7% plateau.
- 2025-11-10 15:55 MT: Flattened the shared-cache export path (ConvertTo-SharedCacheEntryArray) and re-enabled SkipSiteCacheUpdate=true in Data/StateTraceSettings.json, so the preserved-session harness now captures seven shared sites after the cold pass and restores them before the warm pass without warnings (warmrun-20251110-152703.log). Despite the healthier snapshot, the latest run (Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs, Tools/Invoke-WarmRunTelemetry.ps1 … -AssertWarmCache -PreserveSkipSiteCacheSetting -OutputPath Logs\IngestionMetrics\WarmRunTelemetry-20251110-155700.json) still shows zero reuse: Logs/IngestionMetrics/2025-11-10.json reports cold InterfaceSyncTiming hits at 74/1,289 but warm hits stay 0/86, DatabaseWriteBreakdown.SiteCacheProvider=Cache remains 0/86, and WarmInterfaceCallAvgMs≈457.3 ms vs. Cold≈450.6 ms. SiteExistingRowCacheState events confirm CacheEnabled=true and SiteHostEntryCount climbs per site, yet every host logs LoadCacheMiss=true, implying the cached host objects lose their Rows payload before Update-InterfacesInDb can read them. Follow-up: trace how Normalize-SiteExistingRowCacheHostEntry outputs end up without Rows when retrieved during the warm pass (likely during snapshot priming/import), fix that plumbing, and retry the preserved-session harness so raw DB hits can finally register and the JSON export starts working again.
- 2025-11-10 19:50 MT: Rebuilt the parser-side site cache plumbing so keyed caches survive cross-runspace warm runs (`StateTrace.Parser.SiteExistingRowCacheHolder`, `Get/Set/Import-SiteExistingRowCacheSnapshot*`, `Write-SiteExistingRowCacheTelemetry`). ParserWorker now primes the snapshot via `Initialize-SiteExistingRowCacheSnapshot`, ParserRunspaceModule imports snapshots per worker, and the refreshed suites (`Modules/Tests/ParserPersistenceModule.Tests.ps1`, `ParserWorker.Tests.ps1`, `DeviceLogParserModule.Tests.ps1`) are green. The latest cold pipeline + preserved-session replay still fails the raw guardrail:
  - Cold: `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` (telemetry in `Logs/IngestionMetrics/2025-11-10.json`, keyed snapshot `Logs/SiteExistingRowCacheSnapshot-20251110-173500.clixml` with 43 host entries across BOYO/LABS/SITE/SNAP/SW1/WLLS`).
  - Warm (telemetry capture only): `Tools/Invoke-WarmRunTelemetry.ps1 … -AssertWarmCache:$false -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-20251110-173500.json` recorded `ColdInterfaceCallAvgMs=397.50 ms`, `WarmInterfaceCallAvgMs=403.28 ms` (-5.77 ms regression), `WarmCacheHitRatioPercentRaw=0%`, `WarmCacheProviderMissCount=830/1389`, and `WarmSignatureMatchMissCount=1389`. `SiteExistingRowCacheState` logged 453 warm events with only 34 cache hits (~7.5%).
  - Guard run with `-AssertWarmCache` still aborts (no telemetry export) because the warm pass reports every host without `SiteCacheProvider=Cache`. Root cause: we hydrate the keyed cache during the cold pass, but `Update-InterfacesInDb` zeroes `$existingRows` immediately after we pull the cached host, so the warm pass still issues an Access `SELECT` before diffing. Fixing that ordering (keep `$existingRows` populated before the ADODB query and preserve `SiteCacheExistingRowSource='SiteExistingCache'` through to `DatabaseWriteBreakdown`) is the next milestone before rerunning `Tools/Invoke-WarmRunTelemetry.ps1 -AssertWarmCache`.
