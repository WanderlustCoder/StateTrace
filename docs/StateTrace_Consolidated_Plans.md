- 2025-10-15 15:12 MT planning: Review the 2025-10-15 ingestion telemetry and ParserPersistenceModule instrumentation to understand why  `InterfaceSyncTiming` events are missing before modifying any modules. 
- 2025-10-15 15:12 MT planning: After the emission path is understood, run the dispatcher harness (and pipeline if required) to capture  `InterfacePortQueueMetrics` alongside restored `InterfaceSyncTiming` payloads and document the telemetry results. 
- 2025-10-15: Planned to investigate missing  `InterfaceSyncTiming` payloads before modifying modules and to rerun dispatcher/pipeline telemetry captures once the gap is understood. 
- 2025-10-15 15:46 MT status: Confirmed the emission gap-`Update-InterfacesInDb` threads stream metrics into `InterfaceSyncTiming` without initializing them, so strict mode raises `VariableIsUndefined` and the telemetry write is skipped. Proceeding to patch the module to hydrate those fields from `$bulkMetrics` (zero default) and add regression coverage before rerunning the dispatcher harness.
- 2025-10-15 16:30 MT status: Telemetry validation complete. `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` now yields 37 `InterfaceSyncTiming` events with zero `StreamRowsCloned` and healthy stream metrics (`StreamCloneDurationMs` avg 22.2 ms / p95 53.7 ms, `StreamDispatchDurationMs` avg 34.2 ms / p95 64.1 ms). Closing the follow-up plan; next investigations revert to the InterfaceCall latency tail using the restored telemetry.
- 2025-10-15 16:45 MT status: Dispatcher harness recorded `InterfacePortQueueMetrics` (queue build 18.9-26.5 ms, delay <=103 ms) while `DatabaseWriteBreakdown` still shows InterfaceCallDuration 1.5-10.5 s for the same hosts. Queue setup is effectively free; remaining latency sits upstream of dispatch. Next study: trace wait between ParserPersistence completion and DeviceRepository telemetry to locate the missing seconds.
- 2025-10-15 17:05 MT status: Instrumented ParserPersistence with `SiteCacheFetchDurationMs`/`SiteCacheRefreshDurationMs` and mirrored them into `DatabaseWriteBreakdown`; `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1` confirms coverage. Pipeline rerun (after module reload) still reports InterfaceCallDurationMs >>> queue metrics (BOYO ~2.0 s, WLLS ~10.5 s) with cache fetch timing pending a fresh process to avoid primed site caches. Follow-up: run dispatcher/UI capture from a cold shell to log the new cache durations and decide where the remaining 9+ s accumulate.
- 2025-10-15 17:20 MT status: Cold-shell pipeline (`powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`) captured WLLS-A07-AS-07 with `SiteCacheFetchDurationMs` 14.50 s versus `InterfaceCallDurationMs` 16.57 s (refresh stayed 0; bulk/stream timings <100 ms). Confirms site cache hydration dominates the tail; next step is to flush Access caches between sites or add DeviceRepository load instrumentation so additional hosts surface their fetch costs before tuning begins.
- 2025-10-15 17:35 MT status: DeviceRepository now logs `InterfaceSiteCacheMetrics` (hydration vs. refresh) and exposes `SiteCacheFetchStatus` plus snapshot/build durations and host counts through ParserPersistence/DatabaseWriteBreakdown. `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` and `Modules/Tests/ParserPersistenceModule.Tests.ps1` both pass with the new coverage. Fresh pipeline replay (logs reset) reused prior ingestion history, so no new `InterfaceSyncTiming` rows emitted; action item is to clear `Data/IngestionHistory` and rerun so the new telemetry fields and site-cache metrics appear in `Logs/IngestionMetrics/2025-10-15.json` before profiling the 14.5 s hydrate path.
- 2025-10-15 18:05 MT status: Cleared `Data/IngestionHistory` and ran `powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` from a cold shell. `Logs/IngestionMetrics/2025-10-15.json` now captures `InterfaceSiteCacheMetrics` (BOYO Hydration 4.913 s / Snapshot 2.849 s / Build 2.063 s; WLLS Hydration 14.781 s / Snapshot 10.783 s / Build 3.998 s) and `DatabaseWriteBreakdown.SiteCacheFetchDurationMs` for every host (BOYO p95 4.974 s, WLLS p95 14.497 s, max 14.790 s). Remaining follow-up is to profile `DeviceRepository\Get-InterfaceSiteCache` hydration stages to cut the 14–15 s WLLS fetch tail.
- 2025-10-15 18:20 MT planning: Instrument `DeviceRepository\Get-InterfaceSiteCache`/`Get-InterfacesForSite` with stage-level metrics (provider, query attempts, wait duration, template load and materialize timings) and propagate the breakdown through `InterfaceSiteCacheMetrics` and `DatabaseWriteBreakdown` before rerunning the cold-shell pipeline to validate reductions.
- 2025-10-15 18:45 MT status: Stage-level telemetry landed. Cold-shell pipeline replay records BOYO `InterfaceSiteCacheMetrics` with Query 1.99 s / Execute 8 ms / Materialize 1.97 s / Template 95 ms / Build 1.91 s (Hydration 6.31 s) and WLLS with Query 7.10 s / Execute 46 ms / Materialize 3.05 s / Template 14 ms / Build 3.80 s (Hydration 14.42 s); all runs show QueryAttempts=1 and ExclusiveRetryCount=0. `DatabaseWriteBreakdown` now surfaces the same fields per host (post-hydration fetch slices fall below 4 ms). Next focus: investigate the ADODB recordset enumeration and host-map materialization hotspots that account for ~10 s of the WLLS cache hydrate.
- 2025-10-16 11:58 MT status: Cold-shell pipeline rerun (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`) after clearing `Data/IngestionHistory` produced `Logs/IngestionMetrics/2025-10-16.json` with hydrations now sub-second. `InterfaceSiteCacheMetrics` reports BOYO Hydration max 0.637 s / Snapshot 0.517 s / Materialize 0.213 s / Build 0.136 s and WLLS Hydration max 0.534 s / Snapshot 0.362 s / Materialize 0.173 s / Build 0.172 s (prior 4.9-14.8 s hydrate, 2.8-10.8 s snapshot, 2.1-4.0 s build). `DatabaseWriteBreakdown.SiteCacheFetchDurationMs` now tops out at 0.698 s (BOYO-A05-AS-02) with WLLS hosts <=0.536 s and p95 ~1 ms.
- 2025-10-16 12:05 MT planning: Investigate the remaining ~0.6-0.7 s fetch time on BOYO-A05-AS-02 to confirm whether port sort/materialize stages or the Access query plan dominates, and ensure the reduced durations persist under longer ingest runs.
- 2025-10-16 12:26 MT status: Instrumented `Get-InterfaceSiteCache` and `Get-InterfacesForSite` with `HydrationHostMapDurationMs`/`HydrationSortDurationMs`, threaded the fields through `InterfaceSiteCacheMetrics`, `InterfaceSyncTiming`, and `DatabaseWriteBreakdown`, and refreshed DeviceRepository/ParserPersistence tests (`Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1`, `Modules/Tests/ParserPersistenceModule.Tests.ps1`). Next action: rerun the cold-shell pipeline to capture the new sort/host-map timings and confirm they explain the 0.15-0.25 s residual before attempting pooling experiments.
- 2025-10-16 12:32 MT status: Broke down `Logs/IngestionMetrics/2025-10-16.json` for BOYO. Hydration averages 0.607 s with Snapshot 0.490 s (Query 0.105 s; Materialize 0.183 s made up of PortSort 0.086 s, Template 0.045 s, Object 0.023 s, Projection 0.016 s) plus a consistent 0.15-0.25 s residual inside `Get-InterfacesForSite` (likely the post-materialize sort). Host-map Build contributes another 0.114 s. WLLS runs at 0.449 s (Query 0.017 s; Materialize 0.139 s with PortSort 0.094 s; Build 0.142 s; residual 0.13-0.17 s). Access execution is now a minor slice; remaining tail lives in materialize/sort/build work.
- 2025-10-16 12:35 MT planning: Add explicit telemetry around the list sort and host-map build loops, then prototype reuse strategies (e.g., pre-sorted buffers, dictionary pooling) before the next cold-shell replay to shave the remaining 0.13-0.25 s from fetch.
- 2025-10-15 16:20 MT status: `InterfaceModule\Get-PortSortKey` now caches normalized ports (concurrent dictionary + telemetry counters) and `DeviceRepositoryModule` pre-sizes materialize collections before looping. Cold-shell pipeline (`powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`, ingestion history reset) reports BOYO `SiteCacheMaterializePortSortDurationMs` averaging 0.301 s (p95 0.365 s, max 0.365 s) and WLLS averaging 1.936 s (p95 3.013 s, max 3.013 s). Cache telemetry logged ~6.5k hits / 1.15k misses for BOYO (steady cache size ≈96) and ~29.4k hits / 1.20k misses for WLLS (cache ≈144). Remaining materialize tail sits in the WLLS template/object slices; next profiling pass will target those phases now that port-sort misses have flattened.
- 2025-10-15 19:35 MT status: Enumeration refactor (recordset `GetRows`) and host-map property caching completed. Cold-shell pipeline (`powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`) after clearing `Data/IngestionHistory` now reports WLLS Hydration 7.03 s (Query 0.116 s vs. 7.10 s, Materialize 3.43 s, Build 1.61 s vs. 3.80 s, Snapshot 5.42 s) and BOYO Hydration 0.67 s (Query 0.028 s vs. 1.99 s, Materialize 0.30 s vs. 1.97 s, Build 0.15 s vs. 1.91 s). `DatabaseWriteBreakdown.SiteCacheFetchDurationMs` tops out at 3.7 ms (was 14.5 s) while `InterfaceCallDurationMs` remains 8-9.9 s because `SnapshotDurationMs` + `MaterializeDurationMs` still dominate refreshed runs. Next plan: profile the materialize pipeline (PortSort generation, template lookups, PSCustomObject allocation) and audit snapshot stopwatch scope so the remaining 3.4 s materialize cost can be trimmed.
- 2025-10-15 20:05 MT status: Materialize instrumentation harvested per-stage timings. Cold-shell pipeline (history reset) records BOYO `SiteCacheMaterializePortSortDurationMs` averaging 0.238 s (projection 14.6 ms, template 12.6 ms, object build 36.3 ms; total materialize 0.677 s) while WLLS averages 3.013 s port-sort, 56.8 ms projection, 110.5 ms template, and 451.9 ms object build (materialize 2.700 s with `SnapshotDurationMs` 7.276 s). PortSort dominates the hydrate tail; next actions are to benchmark/cached-optimize `InterfaceModule\Get-PortSortKey`, reuse per-vendor template hints, and pre-size host dictionaries before evaluating broader snapshot batching.
- 2025-10-15 21:15 MT status: Precompiled `Get-PortSortKey` normalization rules, cached type weights, and trimmed segment allocation to cut per-port parsing overhead; extended `Modules/Tests/InterfaceModule.Tests.ps1` with normalization fixtures and confirmed via `Invoke-Pester`. Next: rerun the cold-shell pipeline to capture updated `SiteCacheMaterializePortSortDurationMs`/cache-hit telemetry and decide if template hint reuse is still required.
- 2025-10-16 08:45 MT status: Cold-shell pipeline (ingestion history cleared) now reports BOYO `SiteCacheMaterializePortSortDurationMs` 94.7 ms avg (cache hits: 6.5k, misses: 1.15k) and WLLS 100.7 ms avg (hits: 29.4k, misses: 1.20k), down from the prior 238 ms / 3.013 s tail. `DatabaseWriteBreakdown` shows InterfaceCallDurationMs capped at 1.10 s (BOYO) / 0.85 s (WLLS) with DatabaseWriteLatency p95 <= 1.23 s. Remaining latency sits in SnapshotDurationMs (516 ms BOYO / 362 ms WLLS) and overall materialize totals (~161-173 ms). Next: explore template hint reuse and object-build pooling to shave the remaining 150-500 ms from snapshot/materialize phases.
- 2025-10-16 09:40 MT status: Template hint cache + pooled interface record model landed. Fresh pipeline run (history reset) drops WLLS `SiteCacheMaterializeTemplateDurationMs` to 16.1 ms avg (p95 22.0 ms, was 110+ ms) with object construction 26.7 ms avg (p95 49.1 ms). BOYO now holds 46.1 ms template avg (p95 80.1 ms) / 24.3 ms object avg (p95 26.4 ms) despite higher mixed payload counts. Port-sort remains ~89-95 ms avg; SnapshotDuration still dominates (BOYO 493 ms avg / WLLS 320 ms). Next step: focus on snapshot assembly and cached metadata reuse so materialize totals fall below 120 ms and snapshot <250 ms before re-running the UI harness.
- 2025-10-16 10:25 MT status: Updated `DeviceRepository\Get-InterfacesForSite` to reuse per-host metadata (site, zone, vendor, building) and replace repeated string concatenations with direct casts so projection overhead shrinks before port-sort/template stages. `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` and `Modules/Tests/ParserPersistenceModule.Tests.ps1` both pass; need a fresh cold-shell pipeline to capture the delta in `InterfaceSiteCacheMetrics`/`DatabaseWriteBreakdown` snapshot durations.
- 2025-10-16 11:10 MT status: Rebuilt `Get-InterfaceSiteCache` snapshot assembly to emit typed `InterfaceCacheEntry` rows and reuse host dictionaries, avoiding per-row `PSObject` projections during hydration. Targeted Pester suites (`Modules/Tests/DeviceRepositoryModule.Tests.ps1`, `Modules/Tests/ParserPersistenceModule.Tests.ps1`) pass. Next action: run a cold-shell pipeline replay (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`) to confirm `HydrationSnapshotMs` reduction versus the 493 ms / 320 ms baselines and update telemetry docs with the new figures.
- 2025-10-16 12:35 MT status: Cold-shell pipeline rerun after host-map/sort instrumentation captured `Logs/IngestionMetrics/2025-10-16.json` with BOYO hydration peaking at 0.64 s (`SnapshotDurationMs` 517 ms, `HostMapDurationMs` 147 ms, `SortDurationMs` 45 ms) and WLLS at 0.53 s (`SnapshotDurationMs` 362 ms, `HostMapDurationMs` 81 ms, `SortDurationMs` 59 ms). `DatabaseWriteBreakdown` now shows `InterfaceCallDurationMs` p95 at 1.02 s (BOYO) and 0.44 s (WLLS). Follow-up: pursue host-map dictionary reuse or presorted buffers to trim the remaining ~150 ms snapshot cost before revisiting materialize time.
- 2025-10-16 12:52 MT planning: Implement host-map pooling inside `DeviceRepository\Get-InterfaceSiteCache` by reusing per-host dictionaries and `InterfaceCacheEntry` objects from the prior hydration, and skip redundant list sorting when the Access query already orders by `Hostname, Port`. Expectation: drop `HydrationHostMapDurationMs` from 147/81 ms toward <60 ms and push `HydrationSortDurationMs` toward zero without altering downstream consumers. Coding to follow once docs/task board reflect the approach.
- 2025-10-16 13:28 MT status: Host-map pooling and cache signature reuse landed. Cold-shell pipeline replay (`Logs/IngestionMetrics/2025-10-16.json`) now reports BOYO `HydrationHostMapDurationMs` averaging 111.5 ms (max 146.6 ms) with `SnapshotDurationMs` 435.3 ms, while WLLS host-map averages 58.3 ms (max 81.0 ms) and snapshot 292.2 ms. `HydrationSortDurationMs` falls to 14.9 ms (BOYO) / 19.6 ms (WLLS) after bypassing redundant sorts, driving `DatabaseWriteBreakdown.InterfaceCallDurationMs` p95 down to 923.8 ms (BOYO) and 436.2 ms (WLLS). Follow-up: analyze the residual ~35-40 ms host-map work on BOYO's first hydration (signature mismatch path) and decide whether warm-cache seeding or further signature memoization is warranted.

- 2025-10-16 13:47 MT status: Added host-map reuse counters ( `HostMapSignatureMatchCount`, `HostMapSignatureRewriteCount`, `HostMapEntryAllocationCount`, `HostMapEntryPoolReuseCount`) to the DeviceRepository/ParserPersistence telemetry chain. Cold-shell pipeline (logs reset, ingestion history cleared) shows first hydrations rewriting every cached row (BOYO 0 matches / 636 rewrites / 636 allocations, WLLS 0 / 1224 / 1224) before any pool reuse. Follow-up: capture a refresh-driven hydration or deliberate warm run to confirm match counts dominate once signatures stabilize, then decide whether cache seeding is needed or document the one-time cold-start cost. 
- 2025-10-16 13:55 MT status: Ran a same-session warm-run sweep (manual `DeviceRepository\Get-InterfaceSiteCache -Refresh` followed by two `Invoke-StateTraceParsing -Synchronous` passes without tearing down modules). `Logs/IngestionMetrics/2025-10-16.json` still shows every `DatabaseWriteBreakdown.SiteCacheFetchStatus` flipping to `Refreshed` with `SiteCacheHostMapSignatureMatchCount` stuck at 0 (BOYO rewrote 3,240 entries with 2,700 pool reuses / 540 allocations, avg fetch 2.23 ms / max 17.21 ms; WLLS rewrote 13,128 entries with 11,928 reuses / 1,200 allocations, avg fetch 0.80 ms / max 1.69 ms). Need to trace why `ParserPersistenceModule` fails to hit the cached host map between back-to-back runs (forced refresh, signature mismatch, or cache eviction) before pursuing cache seeding guidance).
- 2025-10-16 14:25 MT status: Added host-map resolve telemetry in `ParserPersistenceModule` (`SiteCacheResolveInitial*`, `SiteCacheResolveRefresh*`) and flowed the fields into `DatabaseWriteBreakdown`. Next step is to rerun a warm-run pipeline without explicit refresh to capture the new statuses/key samples so we can pinpoint why the cache path keeps falling back to refreshes.
- 2025-10-16 14:50 MT status: Warm-run pipeline (no `-Refresh`; temporarily renamed `Data/IngestionHistory/*.json` to force reprocessing without touching site caches) recorded `SiteCacheResolveInitialStatus=ExactMatch` and `SiteCacheResolveRefreshStatus=NotAttempted` for all 37 hosts. 35/37 fetches now come back `CacheStatus=Hit` with fetch duration averages at 1.36 ms (BOYO, max 9.35 ms) and 0.43 ms (WLLS, max 0.45 ms). The first host for each site (BOYO-A05-AS-02 at 734.68 ms, WLLS-A01-AS-01 at 557.40 ms) still reports `CacheStatus=Hydrated` even though the resolve stage hit an exact key and the cached map was <0.3 s old. Host-map counters remain at 0 signature matches versus 38,232 rewrites/pool allocations, so the pooled dictionaries are still being rebuilt every run. Follow-up: inspect the first-host hydrate path inside `DeviceRepositoryModule\Get-InterfaceSiteCache` and trace why signature comparisons never register matches, even on back-to-back runs.
- 2025-10-16 21:10 MT status: Updated `DeviceRepository\Get-InterfaceSiteCache` to stage previous host/port dictionaries before clearing them so refresh hydrations can reuse typed cache entries and increment `HydrationHostMapSignatureMatchCount`. Added regression coverage (`It "reuses cached host entries when refresh sees unchanged data"`) and `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` passes (only the longstanding COM warning). Follow-up: rerun the warm-run pipeline without `-Refresh` to confirm the new counters register matches in telemetry and to validate whether the first host per site still reports `CacheStatus=Hydrated`.
- 2025-10-16 21:40 MT status: Warm-run replay (`powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing`) after staging the host-map reuse logic still records 35/37 `DatabaseWriteBreakdown.SiteCacheFetchStatus=Hit`, but `SiteCacheHostMapSignatureMatchCount` stays at 0 while rewrites total 38,232 with zero pool reuses (`Logs/IngestionMetrics/2025-10-16.json`, timestamps ~15:17 MT). The first hosts `BOYO-A05-AS-02` and `WLLS-A01-AS-01` continue to hydrate (fetch 0.554 s / 0.325 s) despite `SiteCacheResolveInitialStatus=ExactMatch` and cache ages <0.4 s, so the cached dictionaries are still being rebuilt on hits. Follow-up: instrument the `$hostMap.TryGetValue` / signature comparison branch in `Modules/DeviceRepositoryModule.psm1` to capture why every row is treated as a rewrite before attempting further cache seeding.
- 2025-10-16 22:05 MT status: Propagated the host-map reuse counters through `ParserPersistenceModule`/`DeviceLogParserModule`, removed duplicate payload fields, and refreshed the associated Pester suites (`Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1, Modules/Tests/ParserPersistenceModule.Tests.ps1`). A fresh warm-run (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing`, telemetry in `Logs/IngestionMetrics/2025-10-16.json` @ `2025-10-16T15:48:25.376-06:00`) now emits the new candidate/miss counters, but WLLS still reports `HostMapSignatureMatchCount=0`, `HostMapSignatureRewriteCount=1224`, `HostMapCandidateMissingCount=1224`, and `HostMapLookupMissCount=25` with `HydrationDurationMs=937.09` even though all rows came from the previous cache. The matching `DatabaseWriteBreakdown` event for `WLLS-A07-AS-07` surfaces the same zero-match telemetry, confirming the plumbing works while the reuse logic still rewrites every port. Follow-up: capture per-port signature text inside the reuse branch (and/or log pre/post `Signature` values in `Set-InterfaceSiteCacheHost`) to determine whether signatures are being lost between runs or if the comparison is trimming/normalizing inconsistently.
- 2025-10-16 22:40 MT status: Added `HydrationHostMapSignatureMismatchSamples` to `DeviceRepository\Get-InterfaceSiteCache` (first five host/port mismatches now retain `PreviousSignature`/`NewSignature` pairs), surfaced the array through `InterfaceSiteCacheMetrics`, `InterfaceSyncTiming`, and `DatabaseWriteBreakdown`, and extended the DeviceRepository/ParserPersistence Pester suites to cover the new payload shape. Follow-up: rerun the warm-run pipeline (no `-Refresh`) to harvest the mismatch samples for WLLS so we can inspect the actual signature deltas driving the persistent rewrites.
- 2025-10-16 22:55 MT status: Warm-run pipeline replay (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing`) after the mismatch-sample instrumentation shows `HydrationHostMapSignatureMismatchSamples` staying empty because every rewritten row still enters via the `HostMapCandidateMissingCount` path (1224 rewrites / 1224 missing, zero mismatches). `DatabaseWriteBreakdown` mirrors the empty sample array. Next step: instrument the candidate-missing branch (e.g., capture the first host/port keys we fail to recover from the previous cache or log what `Set-InterfaceSiteCacheHost` persisted) so we can determine why the prior host dictionary is not providing reuse candidates.
- 2025-10-21 09:22 MT status: Warm-run pipeline (no `-Refresh`) executed after renaming `Data/IngestionHistory/BOYO.json` and `WLLS.json` now emits the candidate-missing samples. `Logs/IngestionMetrics/2025-10-21.json` shows BOYO `HydrationDurationMs=792.853`, `SnapshotDurationMs=711.418`, `HostMapCandidateMissingCount=636` with the first five samples all reporting `Reason=HostSnapshotMissing` on `BOYO-A05-AS-02`, and WLLS `HydrationDurationMs=579.95`, `SnapshotDurationMs=510.09`, `HostMapCandidateMissingCount=1224` with samples rooted at `WLLS-A01-AS-01`. `DatabaseWriteBreakdown.SiteCacheFetchStatus=Hit`, yet `SiteCacheHostMapSignatureMatchCount` stays `0` and the samples persist the same host snapshot miss details for every host. Follow-up: inspect `Set-InterfaceSiteCacheHost` persistence/restore flow and confirm whether the site signature cache loses host dictionaries between runs (suspect reinitialisation clearing entries before reuse).
- 2025-10-21 09:58 MT status: `Set-InterfaceSiteCacheHost` now materializes typed `InterfaceCacheEntry` objects and `Get-InterfaceSiteCache` coerces legacy PSCustomObject cache rows on load via `ConvertTo-InterfaceCacheEntryObject`. Added a warm-run regression in `Modules/Tests/DeviceRepositoryModule.Tests.ps1` plus refreshed ParserPersistence coverage; targeted `Invoke-Pester` runs pass. Sequential warm-run replay (ingestion history renamed, two shared-process pipeline passes) still records `HostMapSignatureMatchCount=0` with `HostMapCandidateMissingCount=636/1224`, so cached host maps are still bypassed before hydration. Follow-up: trace the cache resolve flow in `ParserPersistenceModule`/`DeviceRepositoryModule` to learn why host dictionaries remain undiscovered and finish the cache reuse effort.
- 2025-10-21 10:35 MT status: Extended `InterfaceSiteCacheMetrics` / `InterfaceSyncTiming` with `HydrationPreviousHostCount`, `HydrationPreviousPortCount`, and `HydrationPreviousHostSample`. After reloading modules and running `powershell.exe -NoProfile -File Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing`, WLLS continues to hydrate on the first run of each session (`Logs/IngestionMetrics/2025-10-21.json` @ `2025-10-21T10:25:31.289-06:00` shows `HydrationDurationMs=797.55 ms`, `HostMapSignatureMatchCount=0`, `HostMapCandidateMissingCount=1224`, `PreviousHostCount=0`, `PreviousPortCount=0`). The new counters confirm the cached host dictionary is empty when hydration begins despite `SiteCacheResolveInitialStatus=ExactMatch`. Follow-up: instrument how `Set-InterfaceSiteCacheHost` repopulates `SiteInterfaceSignatureCache` after each host so we can catch where the previous host map is being cleared or skipped before reuse.
- 2025-10-21 11:12 MT status: Added `HydrationPreviousSnapshotStatus`, host-map type/count, and exception fields inside `DeviceRepository\Get-InterfaceSiteCache` and propagated them through ParserPersistence/DeviceLogParser telemetry. Warm-run captures should now show whether reuse fails because the prior host map is missing, unsupported, or throwing conversion errors before hydration. Next action: rerun the warm pipeline (no `-Refresh`) so the new diagnostics populate `Logs/IngestionMetrics` and pinpoint why `HydrationPreviousHostCount` remains zero for WLLS.
- 2025-10-21 10:56 MT status: Reran `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing` without `-Refresh` after the telemetry additions. `Logs/IngestionMetrics/2025-10-21.json` captured a fresh WLLS entry (`Timestamp=10:53:11 MT`) with `CacheStatus=Hydrated`, `PreviousSnapshotStatus=CacheEntryMissing`, `PreviousHostCount=0`, `PreviousPortCount=0`, `HostMapSignatureMatchCount=0`, `HostMapSignatureRewriteCount=1224`, and `HostMapCandidateMissingCount=1224`; `DatabaseWriteBreakdown` for the same pass still reports `SiteCacheResolveInitialStatus=ExactMatch`. BOYO reuse counters remain at the prior 09:54 run, so only WLLS produced new metrics this pass. Follow-up: trace the WLLS cache resolve/write path (`ParserPersistenceModule` + `DeviceRepositoryModule`) to learn why the prior host map materializes as `CacheEntryMissing` despite an exact key hit, and confirm the pipeline is cycling BOYO hosts in warm scenarios.
- 2025-10-21 11:57 MT status: Added a `-PreserveModuleSession` switch to `Tools/Invoke-StateTracePipeline.ps1` so warm-run telemetry can reuse in-process module state. Two in-process passes (ingestion history reset between runs) now register true cache reuse: `Logs/IngestionMetrics/2025-10-21.json` @ `11:56:43.061-06:00` shows WLLS `CacheStatus=Refreshed`, `Provider=Cache`, `HostMapSignatureMatchCount=1224`, `HostMapCandidateMissingCount=0`, `PreviousSnapshotStatus=Converted`, and `HydrationDurationMs=233 ms`. The earlier `11:56:13`/`11:56:42` entries remain full hydrations, confirming the second pass is the warm reuse path. Follow-up: circulate the new switch to operators and decide whether warm-run verification should become part of the standing telemetry checklist.
- 2025-10-21 13:22 MT status: Documented the `-PreserveModuleSession` workflow in the operator runbook and task board. We are keeping the switch opt-in so cold-shell regressions stay visible by default; operators should enable the flag during reuse diagnostics and capture the resulting `HostMapSignatureMatchCount`/`HydrationDurationMs` deltas in their session notes. Remaining follow-up: collect operator feedback on the new checklist step and revisit whether the harness should default to preserved sessions after the next telemetry sweep.
- 2025-10-21 14:10 MT status: Introduced `Tools/Invoke-WarmRunTelemetry.ps1` to automate preserved-session warm-run captures (parameters `-ColdHistorySeed`/`-WarmHistorySeed`, optional JSON export). A trial run (`.\Tools\Invoke-WarmRunTelemetry.ps1 -ColdHistorySeed Empty -WarmHistorySeed Snapshot`) recorded cold-pass hydrations at BOYO 648.93 ms and WLLS 663.84 ms (`Provider=ADODB`, `HostMapSignatureMatchCount=0`), but the warm pass emitted no `InterfaceSiteCacheMetrics`, leaving cache reuse unconfirmed. Follow-up: refine ingestion-history seeding so the warm pass surfaces the expected `Provider=Cache` + non-zero match counts, or escalate if the pipeline continues to bypass cached host dictionaries despite preserved modules.
- 2025-10-21 14:38 MT status: Updated `Tools/Invoke-WarmRunTelemetry.ps1` to capture the post-cold ingestion snapshot so preserved-session warm passes reuse the cold-pass history before rerunning. Replayed the automation (`.\Tools\Invoke-WarmRunTelemetry.ps1 -VerboseParsing`, `-ColdHistorySeed Empty -WarmHistorySeed Snapshot`, and `-ColdHistorySeed Empty -WarmHistorySeed Empty`); each cold pass logged the expected hydrations (BOYO `HydrationDurationMs` ~0.69-0.71 s, WLLS ~0.55-0.58 s with `Provider=ADODB`), but every warm pass still emitted no `InterfaceSiteCacheMetrics`; `Logs/IngestionMetrics/2025-10-21.json` around `14:30:58-14:30:59 MT` only adds `SkippedDuplicate` events. Follow-up: trace the preserved-session warm path to confirm DeviceRepository telemetry fires on cache hits or identify why cached host maps are bypassed despite shared module state.
- 2025-10-21 15:06 MT status: Added `Publish-InterfaceSiteCacheTelemetry` inside `DeviceRepositoryModule\Get-InterfaceSiteCache` so cache hits now emit `InterfaceSiteCacheMetrics` (including host/row counts) instead of returning silently. Updated both cache-hit and hydration paths to reuse the helper; targeted `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` passes. Warm-run automation still records only `SkippedDuplicate` events because the preserved warm pass skips ingestion when seeded with the post-cold snapshot—next follow-up is to feed the warm pass pre-run history (or relax duplicate suppression) so the new cache-hit telemetry surfaces during automation.
- 2025-10-21 19:54 MT status: Extended `Tools/Invoke-WarmRunTelemetry.ps1` with a `-RefreshSiteCaches` option and defaulted warm-pass seeding to the preserved warm-run backups. Running `.\Tools\Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches` now issues cache-refresh calls between passes and the second invocation emits `InterfaceSiteCacheMetrics` with `CacheStatus=Refreshed`, `Provider=Cache`, `HostMapSignatureMatchCount=1224`, and `HydrationDurationMs` in the 210-240 ms range (`Logs/IngestionMetrics/2025-10-21.json` @ `19:54:11-19:54:24 MT`). Follow-up: propagate the new workflow to the operator runbook/task board and remind operators to clean up or archive the generated `.warmrun.*.bak` history snapshots after telemetry collection.
- 2025-10-22 19:55 MT status: Added a process-wide fallback (`StateTrace.Repository.SharedSiteInterfaceCacheHolder`) so `Initialize-SharedSiteInterfaceCacheStore` can adopt an existing AppDomain dictionary instead of stamping a fresh store; `Clear-SiteInterfaceCache` now keeps the holder aligned with the AppDomain slot, and `Modules/Tests/DeviceRepositoryModule.Tests.ps1` includes a regression that clears the slot while asserting cache hits are still served. Targeted `Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1` passes, but `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches` (2025-10-22 19:56 MT) still shows the preserved warm pass hydrating from ADODB with `HostMapSignatureMatchCount=0`, and `Logs/IngestionMetrics/2025-10-22.json#20421` records `InterfaceSiteCacheSharedStoreState=InitNewStore` (RunspaceId `e0fc37df-5a2b-4bd6-ac28-3fb9e143e5b5`, `StoreHashCode=19434694`) before the second run. Follow-up: investigate why new worker runspaces miss the shared dictionary despite the holder (suspect per-runspace type loading or holder resets) and close the loop once `Provider=Cache` + non-zero signature matches appear in the warm automation.
- 2025-10-21 20:12 MT status: Operator-facing docs updated (runbook warm-run section, task board card) with the `-RefreshSiteCaches` workflow, telemetry expectations, and the `.warmrun.*.bak` cleanup reminder. Standing follow-up: sample the helper during the next BOYO/WLLS validation window, gather operator feedback on the revised steps, and decide whether to promote automated JSON exports or additional flags in a subsequent iteration.
- 2025-10-22 09:58 MT status: Executed `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-latest.json`. Cold pass completed and the scripted refresh step reported no cache-hit telemetry; the warm pass still hydrated from Access (`Provider=ADODB`) for both BOYO (Hydration 585 ms, Snapshot 510 ms, `HostMapSignatureMatchCount=0`) and WLLS (Hydration 555 ms, Snapshot 486 ms, `HostMapSignatureMatchCount=0`). Exported summary confirms every host lists `PreviousSnapshotStatus=CacheEntryMissing`. Follow-up: inspect why the in-script refresh (`DeviceRepositoryModule\Get-InterfaceSiteCache -Refresh`) fails to persist host maps before the warm invocation, or whether pipeline invocation with `-PreserveModuleSession` clears caches despite expectations.
- 2025-10-22 10:05 MT status: Added a cache probe hook inside `Tools/Invoke-WarmRunTelemetry.ps1` (invokes `DeviceRepositoryModule\Get-InterfaceSiteCache -Site <site>` after the scripted refresh) so we can capture telemetry before the warm pass. Replayed `.\Tools\Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-latest.json`; the probe emitted no `InterfaceSiteCacheMetrics` (`Get-AppendedTelemetry` returned zero events), and the warm pass continues to report `Provider=ADODB`, `CacheStatus=Hydrated/Hit`, `HostMapSignatureMatchCount=0`, `PreviousSnapshotStatus=CacheEntryMissing` (BOYO Hydration 616 ms, Snapshot 537 ms; WLLS Hydration 548 ms, Snapshot 477 ms). Follow-up: diagnose whether `TelemetryModule\Write-StTelemetryEvent` is suppressed outside pipeline runs or if the refresh path still clears `$script:SiteInterfaceSignatureCache` prior to the warm invocation; trace DeviceRepository cache state immediately after the refresh call.
- 2025-10-22 10:38 MT status: Instrumented the helper to log cache state via `Get-SiteCacheState` (uses the module session to inspect `$script:SiteInterfaceSignatureCache`). Latest run (`Logs/IngestionMetrics/WarmRunTelemetry-latest.json`, console timestamps 10:37 MT) shows the cache-state summaries returning `0` entries for both BOYO and WLLS immediately after refresh and before the warm pass, aligning with the persistent `PreviousSnapshotStatus=CacheEntryMissing` telemetry. Follow-up: capture the module cache contents manually (e.g., `Get-Module DeviceRepositoryModule | % { $_.Invoke({ $script:SiteInterfaceSignatureCache.Keys }) }`) right after the helper refresh to confirm the dictionary is empty, then audit `Tools/Invoke-StateTracePipeline.ps1` import flow or DeviceRepository cleanup logic for unintended cache clears.
- 2025-10-22 11:20 MT status: Parser runspace preservation is in place (`ParserRunspaceModule` caches the runspace pool, exposes `Reset-DeviceParseRunspacePool`, and the pipeline/ParserWorker path now passes `-PreserveRunspace`). Updated `Tools/Invoke-WarmRunTelemetry.ps1` to reuse the preserved pool, seed caches via `Invoke-InterfaceSiteCacheWarmup`, and throttle the warm pass to single-thread overrides. Despite the changes, the latest helper run (`Logs/IngestionMetrics/WarmRunTelemetry-latest.json`, 11:09 MT) still reports warm-pass `InterfaceSiteCacheMetrics.Provider=ADODB`, `HostMapSignatureMatchCount=0`, and `HydrationDurationMs` ≈0.57 s (WLLS) / 0.59 s (BOYO). Follow-up: investigate runspace affinity—preserved pools may dispatch new worker runspaces for warm runs so cached dictionaries never survive into the second pass.
- 2025-10-22 11:45 MT status: Added Get-InterfaceSiteCacheSummary to DeviceRepositoryModule and runspace-level telemetry (InterfaceSiteCacheRunspaceState) for cache reuse diagnostics. The warm-run helper (Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches, 11:32-11:33 MT) shows cold-pass workers starting with empty dictionaries (CacheExists=false for the first BOYO/WLLS hosts, e.g., Logs/IngestionMetrics/2025-10-22.json:6257) while warm-pass workers see populated host maps (CacheStatus=Hydrated, HostCount=25 at Logs/IngestionMetrics/2025-10-22.json:6814). Even with cached entries present, warm-pass telemetry still reports Provider=ADODB, HostMapSignatureMatchCount=0, and HostMapCandidateMissingCount equal to the total row counts (Logs/IngestionMetrics/WarmRunTelemetry-latest.json). Next action: trace the candidate-missing/rewrite branch forcing the hydrate path so the first warm-run host can avoid requerying, and investigate why no Warmup* runspace events emitted during the scripted refresh.
- 2025-10-22 15:34 MT status: Migrated the shared site-interface cache from the runspace-scoped static type to an AppDomain-level concurrent dictionary (new `Initialize-SharedSiteInterfaceCacheStore` / `Get-SharedSiteInterfaceCacheStore` helpers in DeviceRepositoryModule) and updated the cross-runspace regression to assert cache hits succeed without touching Access. Cold-pass workers now emit `InterfaceSiteCacheSharedStore` `Set` telemetry with `EntryCount=1` for BOYO and `EntryCount=2` for WLLS, confirming cache entries land in the process-wide store, but the preserved warm pass still logs `GetMiss` events with `EntryCount=0/1` before hydrating from ADODB (Logs/IngestionMetrics/2025-10-22.json ~14:33:51 MT). Follow-up: reconcile the warm-run helper with the new store-either keep the parser pool configuration stable across passes or seed the AppDomain cache after the thread-override reset-so subsequent warm runs produce non-zero `HostMapSignatureMatchCount` values.
- 2025-10-22 13:40 MT status: Introduced a shared site-interface cache store inside DeviceRepositoryModule (concurrent dictionary + deep-clone helpers) so runspaces can repopulate $script:SiteInterfaceSignatureCache from a process-wide snapshot. Added cross-runspace regression coverage (Modules/Tests/DeviceRepositoryModule.Tests.ps1 now instantiates a secondary runspace and asserts cache hits succeed without touching Access). Manual warm-run automation still reports HostMapSignatureMatchCount=0 because the shared store is not populated during pipeline execution-[StateTrace.Repository.SharedSiteInterfaceCacheStore]::SiteCache remains empty after cold and warm passes. Follow-up: trace where worker modules load DeviceRepository and confirm Set-SharedSiteInterfaceCacheEntry executes in the worker runspaces (expect to inspect Initialize-WorkerModules / parser invocation) before re-testing the preserved-session helper.
- 2025-10-22 14:13 MT status: Shared-cache helpers now emit `InterfaceSiteCacheSharedStore` telemetry (runspace ID, entry count, host/row totals). Cold-pass workers running in RunspaceId `94780137-574d-4262-9fe8-41f2179546fb` log `Set` events with `EntryCount=1` for BOYO (`TotalRows=636`) and `EntryCount=2` for WLLS (`TotalRows=1224`) immediately after hydration (`Logs/IngestionMetrics/2025-10-22.json`, line indices ~12160-12240). The preserved warm pass executes inside RunspaceId `2767d60f-a6ab-425b-8ff4-1150d6f2ade0` and records only `GetMiss` events with `EntryCount=0/1` before the Access fallback (`Logs/IngestionMetrics/2025-10-22.json`, line indices ~12690-12730), proving the static store is scoped to each worker runspace. Next step: initialize the shared store in a module scope that survives runspace creation (or marshal cache entries back into the preserved pool) so warm runs can hit the cache before `Get-InterfaceSiteCache` rehydrates from ADODB.
- 2025-10-22 15:58 MT status: Updated "Tools/Invoke-WarmRunTelemetry.ps1" so single-thread overrides are applied before the cold pass (cold/warm now share the same runspace config). Warm-run automation still hydrates via ADODB ("HostMapSignatureMatchCount=0" for BOYO/WLLS in Logs/IngestionMetrics/WarmRunTelemetry-latest.json ~15:54 MT) even though a shared-cache snapshot after refresh shows entries for both sites. Next: instrument "DeviceRepositoryModule\Get-SharedSiteInterfaceCacheEntry" to learn why preserved worker runspaces return "GetMiss" just before warm hydrations.
- 2025-10-22 16:32 MT status: Extended `InterfaceSiteCacheSharedStore` telemetry to include AppDomain, process, thread, and store-hash identifiers and added parser runspace pool logging. Warm-run helper telemetry (`Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches`, runs ending ~16:25 MT) shows cold and warm passes executing in AppDomain 1 with a stable store hash (`StoreHashCode=61268168`), yet each preserved warm pass still records `GetMiss` events with `EntryCount` dropping back to 0/1 before hydration (`Logs/IngestionMetrics/2025-10-22.json` lines ~17240-18480). No `ParserRunspacePoolState` events emitted because the pipeline continues down the synchronous worker path (no runspace pool reuse to inspect). Follow-up: instrument the `Set-SharedSiteInterfaceCacheEntry`/`Get-InterfaceSiteCache` removal path to learn which caller clears the shared dictionary between passes and why `HostMapSignatureMatchCount` remains 0 despite preserved sessions.
- 2025-10-23 10:19 MT status: Updated `Tools/Invoke-WarmRunTelemetry.ps1` to snapshot shared cache entries after the cold pass (and optional refresh) and restore them before the warm run (`SharedCacheSnapshot:*`, `SharedCacheRestore:PreWarmPass` entries in `Logs/IngestionMetrics/WarmRunTelemetry-latest.json`). Despite the automation, the latest run (10:18 MT) captures `EntryCount=0` and `RestoredCount=0`, and warm-pass telemetry still reports `Provider=ADODB`, `HostMapSignatureMatchCount=0`, and `HostMapSignatureRewriteCount=1224` for WLLS hosts (`Logs/IngestionMetrics/2025-10-23.json` line ~2610). Conclusion: the helper cannot see any entries in `Get-SharedSiteInterfaceCacheStore` immediately after the cold pass, implying the worker runspace never populates the AppDomain store visible to the harness. Follow-up: trace within `Initialize-SharedSiteInterfaceCacheStore`/`Set-SharedSiteInterfaceCacheEntry` to confirm the worker runspace is targeting the same AppDomain data slot, or move the capture/restore logic into the parser runspace itself so the warm run receives seeded dictionaries.
- 2025-10-23 11:40 MT status: Added \\InterfaceSiteCacheReuseState\\ telemetry inside DeviceRepositoryModule to snapshot cached host-map composition on cache hits. Warm-run replay (\\Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches\\) now emits reuse events showing WLLS host maps with 25 hosts / 1,224 ports persisted across the pass, yet \\InterfaceSiteCacheMetrics\\ still reports zero signature matches and 1,224 rewrites. Follow-up: trace why ParserPersistence still falls through the candidate-missing path even though cached host dictionaries survive the warm run.
- 2025-10-23 12:07 MT status: Reran `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches`; `Logs/IngestionMetrics/2025-10-23.json` now captures `InterfaceSiteCacheReuseState` entries showing WLLS host maps (25 hosts / 1,224 ports) retained across passes, but `InterfaceSyncTiming` still reports `SiteCacheComparisonSignatureMatchCount=0` with `SiteCacheHostMapCandidateMissingCount=275,400` and `SiteCacheHostMapSignatureRewriteCount=1,224`. Conclusion: ParserPersistence’s resolve path is still dropping into the candidate-missing branch even with the cached dictionaries available. Follow-up: instrument the candidate-missing diagnostics (`HostSnapshotMissing` cases) to identify which comparison fails and decide whether to adjust the resolve logic or seed additional metadata before warm runs. 
- 2025-10-23 12:36 MT status: Added ParserPersistence diagnostics for candidate-missing scenarios (new `SiteCacheExistingRow*` fields and parser annotations on `SiteCacheHostMapCandidateMissingSamples`), refreshed ParserPersistence/DeviceLogParser tests, and ran targeted suites. Follow-up: rerun `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches` to inspect the parser-side fields within the warm-run telemetry and compare them against the DeviceRepository `HostSnapshotMissing` samples.
- 2025-10-23 12:38 MT status: Preserved-session warm telemetry rerun with the parser instrumentation in place. `InterfaceSyncTiming` now reports `SiteCacheExistingRowCount=24` (CacheInitial) for WLLS hosts, and each `SiteCacheHostMapCandidateMissingSamples` entry carries `ParserExistingRowCount=24`, `ParserExistingRowSource=CacheInitial`, and `ParserLoadCacheHit=true` while DeviceRepository still emits `Reason=HostSnapshotMissing`. Conclusion: cached host dictionaries are present when ParserPersistence diff executes; investigation must shift back to DeviceRepository hydration/signature comparison to learn why host-map reuse is still skipped.
- 2025-10-23 13:44 MT status: Reran `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches`; `Logs/IngestionMetrics/2025-10-23.json` still shows warm-pass `InterfaceSiteCacheMetrics` with `Provider=ADODB`, `HostMapSignatureMatchCount=0`, and rewrite counts 636 (BOYO) / 1,224 (WLLS) alongside hydrations holding at 0.68 s / 0.56 s. `InterfaceSiteCacheReuseAttempt` recorded script-cache hits for BOYO 11/12 and WLLS 24/25 attempts, but shared-store hits remain 0 and snapshot telemetry continues to log `InitNewStore` with `EntryCount=0` before the warm pass. Parser diagnostics confirm cached rows exist (`ParserLoadCacheHit=true`, `ParserExistingRowCount=48` in WLLS samples) while DeviceRepository still reports `PreviousHostEntryPresent=false`/`CachedPortCount=0`. Follow-up: inspect `Get-InterfaceSiteCache` reuse lookups and `Set-InterfaceSiteCacheHost` persistence to learn why host dictionaries are not discovered on hits and whether the shared-store reset is discarding entries.
- 2025-10-23 14:05 MT status: Warm-run helper (`Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches`) now reports cache hits end-to-end. `Logs/IngestionMetrics/2025-10-23.json` (`13:59:01 MT`, lines ~7498-7520) records `InterfaceSiteCacheMetrics` with `Provider=Cache`, `HydrationHostMapSignatureMatchCount=636` (BOYO) / `1224` (WLLS), zero rewrites/candidate-missing counts, and `HydrationDurationMs=0`. `InterfaceSiteCacheReuseState` enumerates the 12-host and 25-host typed dictionaries, while `InterfaceSyncTiming` shows `SiteCacheComparisonSignatureMatchCount` mirroring the totals with `ParserExistingRowSource=CacheInitial`. Follow-up: reconcile `DatabaseWriteBreakdown.SiteCache*` fields with the new cache-hit telemetry and update documentation once downstream metrics align.
- 2025-10-23 17:35 MT status: Updated `Tools/Invoke-WarmRunTelemetry.ps1` so `Get-SitesFromSnapshot` enumerates the hash set via `@($sites)` instead of invoking `.ToArray()`, eliminating the `Site cache refresh step failed: Method invocation failed because [System.String] does not contain a method named 'ToArray'.` error that surfaced when the preserved-session regression ran from `Tools/Invoke-StateTracePipeline.ps1 -RunWarmRunRegression`. The pipeline-driven run (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -RunWarmRunRegression -WarmRunRegressionOutputPath Logs/IngestionMetrics/WarmRunTelemetry-verify.json`) now completes with warm passes served entirely from cache (`WarmCacheProviderHitCount=37`, `WarmSignatureMatchMissCount=0`, `SiteCacheProvider=Cache` for every host). Cold vs. warm `InterfaceCallDurationMs` averages fell from 302.255 ms to 297.552 ms (1.56% / 4.703 ms improvement; warm p95 401.833 ms vs. cold 607.193 ms). Follow-up: wire the regression wrapper into CI so cache regressions fail fast rather than relying on manual runs.
- 2025-10-23 14:25 MT status: Extended ParserPersistenceModule cache resolve telemetry (entry type, port signature samples, cache comparison counters) and threaded the fields through DeviceLogParserModule plus regression suites ( `Invoke-Pester Modules/Tests/ParserPersistenceModule.Tests.ps1`, `Invoke-Pester Modules/Tests/DeviceLogParserModule.Tests.ps1`). Next step: rerun the preserved-session warm telemetry helper to validate the new counters surface cache hits (`SiteCacheComparisonSignatureMatchCount`) and record findings. 
- 2025-10-23 15:24 MT status: Executed `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-20251023-1524.json` to capture a preserved-session cold + warm replay. `DatabaseWriteBreakdown` during the cold pass (35 hosts, 2025-10-23T14:20:16-14:20:35 MT) averaged `InterfaceCallDurationMs=362.96` (p95 915.20 ms, max 1.26 s) with the first BOYO host hydrating via ADODB. The warm pass (37 hosts, 14:20:36-14:20:50 MT) averaged `InterfaceCallDurationMs=140.11` (p95 170.43 ms, max 374.09 ms) and every entry reported `SiteCacheProvider=Cache`/`HostMapSignatureMatchCount>0`. No regressions observed; focus now shifts to automating the warm-run verification so future cache changes surface deltas without manual log review.
- 2025-10-23 15:12 MT status: Warm-run telemetry review confirms `DatabaseWriteBreakdown.SiteCache*` now mirrors the cache-hit metrics. `Logs/IngestionMetrics/2025-10-23.json` entries at `13:58:51.984-06:00` (`Hostname=BOYO-A05-AS-35`) and `13:58:58.744-06:00` / `13:59:01.266-06:00` (`Hostname=WLLS-A03-AS-33`, `WLLS-A05-AS-45`) report `SiteCacheProvider=Cache`, `SiteCacheHostMapSignatureMatchCount=636/1224`, zero candidate-missing counts, and reuse-sourced host maps. No additional code changes required; downstream telemetry is aligned and the follow-up is closed.
- 2025-10-23 15:50 MT status: Warm-run helper now enforces cache reuse automatically. `Tools/Invoke-WarmRunTelemetry.ps1 -VerboseParsing -RefreshSiteCaches -AssertWarmCache -OutputPath Logs/IngestionMetrics/WarmRunTelemetry-latest.json` produced a `WarmRunComparison` summary with cold `InterfaceCallDurationMs` avg 416.104 ms (p95 903.201 ms, max 1.47 s) versus warm 137.784 ms (p95 178.685 ms, max 0.37 s), yielding a 278.32 ms / 66.89% improvement while all 37 hosts reported `SiteCacheProvider=Cache` and zero signature rewrites. The new `-AssertWarmCache` switch fails the helper if cache hits drop, signature matches fall to zero, rewrites return, or warm averages exceed cold metrics.
- 2025-10-23 15:56 MT status: Added `Tools/Invoke-WarmRunRegression.ps1` to wrap the helper with `-AssertWarmCache`, emit a timestamped telemetry export, and surface the cold vs. warm summary on stdout (`Cold avg 361.699 ms`, `Warm avg 137.636 ms`, `61.95%` improvement on the latest run). This wrapper is designed for CI/backlog automation; next follow-up is to wire it into the scheduled verification jobs so cache regressions are caught automatically.
- 2025-10-23 16:05 MT status: Updated `AGENTS.md` and `docs/StateTrace_Operators_Runbook.md` so operators run `Tools\Invoke-WarmRunRegression.ps1` for preserved-session validation; expected outputs now call out 60%+ InterfaceCallDuration improvements with all warm hosts served from `SiteCacheProvider=Cache`. Remaining action: hook the wrapper into the CI verification schedule and capture pass/fail telemetry automatically.
- 2025-10-23 16:32 MT status: `Tools/Invoke-StateTracePipeline.ps1` now accepts `-RunWarmRunRegression` (plus optional `-WarmRunRegressionOutputPath`) to execute the preserved-session cache guard immediately after the standard ingestion run. Scheduled verification jobs can enable the switch to export warm-run telemetry and enforce the `AssertWarmCache` assertions without bespoke scripting. Follow-up: update the CI/scheduled job definition to pass the new switch and archive the generated `WarmRunTelemetry-*.json` path alongside existing pipeline outputs.
- 2025-10-23 16:41 MT status: `Split-RawLogs` now skips `Logs\WarmRunTelemetry-*` artifacts so the regression helper's transcripts no longer block ingestion when the pipeline runs with `-RunWarmRunRegression`. First post-change run of `Tools\Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -RunWarmRunRegression` still failed, but the remaining error is that no new `DatabaseWriteBreakdown` events are captured (helper reports "InterfaceCallDuration comparison metrics were not captured"). Follow-up: inspect `Invoke-WarmRunTelemetry.ps1` baseline/appended telemetry flow to learn why cold/warm passes no longer append metrics despite the preserved-session runs processing 37 hosts (verify ingestion history snapshot logic or forced refresh settings).
- 2025-10-23 16:37 MT status: Hardened `Tools/Invoke-WarmRunTelemetry.ps1` telemetry capture by introducing `Collect-TelemetryForPass` (poll/retry plus a timestamp-agnostic `Get-TelemetrySince` fallback) so preserved-session pipeline runs append both `InterfaceSiteCacheMetrics` and `DatabaseWriteBreakdown` even when telemetry flushes lag ingestion. Running `Tools\Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -RunWarmRunRegression -WarmRunRegressionOutputPath Logs\IngestionMetrics\WarmRunTelemetry-verify.json` now gathers the expected events, but the shared cache snapshot taken after the cold pass reports `EntryCount=0` (`tmp_warmrun.log`) and the warm pass hydrates `BOYO-A05-AS-02` (636 rewrites) and `WLLS-A01-AS-01` (1,224 rewrites) via ADODB, yielding `Warm InterfaceCallDurationMs average 328.735 ms` versus cold `296.556 ms` and tripping the `AssertWarmCache` guard. Follow-up: trace why `Get-SharedSiteInterfaceCacheStore` is empty when the regression runs inside the pipeline-launched process (verify adoption before `SharedCacheSnapshot:PostColdPass`) and restore cache reuse before wiring the regression switch into CI.
- 2025-10-23 17:49 MT status: Introduced `Tools\Invoke-StateTraceVerification.ps1` as the scheduled verification entry point. The script wraps the pipeline harness with `-RunWarmRunRegression`, auto-selects a timestamped export path under `Logs\IngestionMetrics\`, and splats parameters so the warm-run helper receives relative paths (avoiding the previous absolute-path duplication). First trial (`Tools\Invoke-StateTraceVerification.ps1 -SkipTests -VerboseParsing`) executed the ingestion pass but failed the warm-run assertion, reporting cold `InterfaceCallDurationMs` avg 302.120 ms versus warm 309.457 ms (no telemetry export produced). Follow-up: investigate why the preserved-session warm pass regressed and restore the expected ~60% improvement before enabling the guard in CI.
- 2025-10-23 19:11 MT status: Hardened `Collect-TelemetryForPass` to ignore pre-baseline events during fallback, and taught `Tools\Invoke-WarmRunRegression.ps1` to seed cold passes from empty ingestion history while `WarmBackup` now falls back to the cold-pass snapshot when no `.warmrun.*.bak` exists. `Tools\Invoke-StateTraceVerification.ps1 -SkipTests -VerboseParsing` now completes with exported telemetry (`Logs/IngestionMetrics/WarmRunTelemetry-20251023-191115.json`) showing cold `InterfaceCallDurationMs` avg 938.038 ms (37 hosts; `Provider=ADODB` for 2, `Cache` for 35) versus warm 763.926 ms (37 hosts, `Provider=Cache`), a 174.112 ms / 18.56% improvement and zero warm cache misses. Follow-up: continue tightening cache reuse so cold passes avoid residual cache hits and recover the earlier ~60% delta.
- 2025-10-23 planning: Reviewed `docs/Core_Ideas.md`, this consolidated plan, and the task board to prepare for the next development push. Immediate priorities are to (1) operationalise the warm-run regression inside the verification pipeline/CI so cache regressions fail fast, (2) keep iterating on cache reuse telemetry until cold passes consistently hydrate via ADODB and warm passes sustain >18% latency gains, and (3) maintain the documentation/metrics feedback loop for every module change.
- 2025-10-23 20:05 MT status: Extended `Tools\Invoke-StateTraceVerification.ps1` so preserved-session verification runs now maintain `WarmRunTelemetry-latest.json` and emit `WarmRunTelemetry-latest-summary.json` (cold/warm averages, improvement, provider hit ratios). These summaries give CI jobs and operators a stable artifact to inspect after each run. Follow-up: wire the verification job to collect the new summary alongside the timestamped export and alert when improvement or cache-hit thresholds regress.
- 2025-10-23 20:32 MT status: Added `Tools\Invoke-StateTraceScheduledVerification.ps1` to drive scheduled verification runs. The wrapper defaults to `SkipTests`, enables `VerboseParsing`, launches `Invoke-StateTraceVerification.ps1 -PassThru`, captures a transcript under `Logs\Verification\StateTraceVerification-<timestamp>.log`, and surfaces the warm-run summary on stdout. Follow-up: integrate this script with the ops scheduler/CI job and hook alerting to `WarmRunTelemetry-latest-summary.json` thresholds.
- 2025-10-23 planning: Prepare the next concurrency experiment by (1) reviewing the latest `Logs/IngestionMetrics/WarmRunTelemetry-*.json` and existing cold-run baselines for current `DatabaseWriteLatency`/`ParseDuration`, (2) running `Tools\Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing` with conservative overrides (`-ThreadCeilingOverride`, `-MaxWorkersPerSiteOverride`, `-MaxActiveSitesOverride`) to simulate reduced autoscale ceilings, and (3) capturing the resulting `ConcurrencyProfileResolved`, `DatabaseWriteLatency`, and site-level cache timings in both the consolidated plan and task board before restoring default autoscale values.
- 2025-10-24 08:34 MT status: Executed the reduced-ceiling trial (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ThreadCeilingOverride 1 -MaxWorkersPerSiteOverride 1 -MaxActiveSitesOverride 1` after clearing `Data/IngestionHistory`). `Logs/IngestionMetrics/2025-10-24.json` reports `ConcurrencyProfileResolved` with all ceilings locked to `1`, `DatabaseWriteLatency` averaging 387.054 ms (max 1,463 ms) versus the previous baseline 352.568 ms (max 4,246 ms), and no measurable change in `ParseDuration` (still 0 ms). Restored the pre-trial ingestion history backups (`*.beforeOverride.*.bak`) so subsequent runs resume default autoscale behaviour. Next: compare site-level hydration timings to confirm the higher average stems from serialized Access commits and decide whether multi-thread ceilings should remain >1 despite the lower tail latency.
- 2025-10-24 08:36 MT status: Parsed `Logs/IngestionMetrics/2025-10-24.json` for `DatabaseWriteBreakdown` and `InterfaceSiteCacheMetrics`. Only the first host per site hydrated from Access (`SiteCacheProvider=ADODB` with `SiteCacheFetchDurationMs` 888.445 ms / `DatabaseWriteLatencyMs` 1,463 ms for BOYO-A05-AS-02 and 661.206 ms / 996 ms for WLLS-A01-AS-01); the remaining 35 hosts reused the cache with `SiteCacheProvider=Cache`, `SiteCacheHostMapCandidateMissingCount=0`, and `SiteCacheHostMapSignatureMatchCount` 636 (BOYO) or 1,224 (WLLS). With ceilings pinned to one worker/site the hydration spikes serialize, lifting the site averages to `AvgDatabaseWriteLatency` 443 ms (BOYO) and 360 ms (WLLS) even though commit time stays ~2.4 ms. Next: capture recommendations (e.g., keep multi-thread ceilings >1 or seed warm cache entries ahead of cold hosts) and, once decided, rerun a default-autoscale pipeline to reconfirm the baseline metrics.
- 2025-10-24 08:38 MT recommendation: Keep multi-worker ceilings enabled (allow `MaxWorkersPerSite`/`MaxActiveSites` to auto-scale) so the first-host hydrate cost overlaps across sites. The telemetry shows cache reuse is already healthy (36/37 hosts on cache with zero candidate-missing counts), so the higher average under the override stems solely from serialized cold hydrations. Rather than introducing pre-hydrate seeding logic, continue with default ceilings and monitor cache hit telemetry after future code changes.
- 2025-10-24 08:46 MT status: Recreated a cold ingestion history (`BOYO.json`, `WLLS.json`) after backing up the prior files to `*.beforeDefaultAuto.20251024-084408.bak`, then reran `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` with autoscale defaults. `ConcurrencyProfileResolved` selected `ResolvedThreadCeiling=8`, `ResolvedMaxWorkersPerSite=4`, and `ResolvedMaxActiveSites=0` (auto) for 37 devices across BOYO/WLLS. `Logs/IngestionMetrics/2025-10-24.json` (events at or after 08:44:28 MT) shows overall `DatabaseWriteLatency` averaging 886.9 ms (BOYO 897.8 ms / WLLS 881.6 ms), driven by the cold hydrations: BOYO-A05-AS-02 fetched from Access in 895.6 ms (snapshot 579.8 ms) while WLLS-A01-AS-01 spiked to 2,720.7 ms (snapshot 2,191.0 ms, materialize 1,633.8 ms). The remaining 35 hosts hit the cache (`SiteCacheProvider=Cache`, `HostMapSignatureMatchCount` 636/1,224, candidate-missing count 0) with commit durations still ~6-7 ms. Follow-up: compare these cold-pass numbers with a warm replay to validate cache reuse keeps averages near the earlier 300-400 ms baseline and document any sustained deltas.
- 2025-10-24 08:52 MT status: Ran the preserved-session warm regression (`Tools/Invoke-WarmRunRegression.ps1 -VerboseParsing`). The helper seeded an empty cold pass (autoscale defaults) and recorded `WarmRunTelemetry-20251024-085040.json` with `ColdInterfaceCallAvgMs` 860.872 ms (p95 1,867.934 ms, max 4,036.419 ms) versus warm 485.105 ms (p95 1,119.127 ms, max 1,208.321 ms), a 375.8 ms / 43.65% improvement. Warm pass reported `WarmCacheProviderHitCount=37`, zero signature rewrites, and per-site cache metrics stayed at hydration 0 ms with 636/1,224 signature matches. Cold provider counts inside the run show the expected two ADODB hydrations (BOYO-A05-AS-02: 2.24 s, WLLS-A01-AS-01: 1.98-2.72 s), confirming the tail remains isolated to the first host per site. Next: determine whether the WLLS cold hydrate (2.7 s) has regressed compared to pre-override baselines (~0.66 s) and, if so, schedule a focused investigation into the WLLS snapshot pipeline.
- 2025-10-24 08:57 MT analysis: Compared WLLS-A01-AS-01 cold hydrations to historical telemetry. `Logs/IngestionMetrics/2025-10-24.json` now reports `SiteCacheFetchDurationMs` 2,720.669 ms (snapshot 2,191.003 ms, materialize 1,633.778 ms) with `DatabaseWriteLatencyMs` 3,518 ms, whereas the 2025-10-23 corpus showed the same host averaging 654.4 ms (42 captures before 19:00 MT, max 1,184 ms). The ~4x increase surfaced immediately after the reduced-ceiling experiment, suggesting a regression in the WLLS snapshot/materialize path rather than autoscale side effects. Follow-up: open a dedicated investigation card targeting the WLLS signature pipeline (focus on snapshot duration and materialize sort) and capture fresh telemetry diffs once the root cause is isolated.
- 2025-10-24 08:59 MT planning: New Ready card opened for the WLLS snapshot/materialize regression. First steps: 1) Diff `InterfaceSiteCacheMetrics` and `DatabaseWriteBreakdown` between BOYO and WLLS for passes where both hydrate from Access to isolate snapshot vs. materialize deltas. 2) Review recent DeviceRepository/ParserPersistence commits (typed cache adoption, host-map pooling, telemetry extensions) for WLLS-specific branches or assumptions. 3) Capture a focused cold run logging `HostMapCandidateMissingSamples` for WLLS to spot data skew or template mismatches. Next update once initial telemetry comparisons are complete.
- 2025-10-24 09:33 MT status: Executed the focused cold pass after clearing WLLS ingestion history (left BOYO history backed up) and reran `Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`. `Logs/IngestionMetrics/2025-10-24.json` entries time-stamped 09:32:53 MT show WLLS-A01-AS-01 still hydrating via Access but at a lower 1,171.86 ms fetch (snapshot 859.37 ms, materialize 593.27 ms, host-map 107.02 ms, template 124.21 ms, port-sort 164.30 ms, UI clone 87.54 ms). All 48 ports remain `HostSnapshotMissing`, yielding `HostMapCandidateMissingCount=1224` with parser-side signatures present (`ParserExistingRowCount=48`). Subsequent WLLS hosts in the same run hit the cache (fetch 33-62 ms, zero candidate-missing counts), confirming the regression continues to isolate to the first host but now fluctuates between ~0.65 s and ~1.2 s rather than the 2.7 s spike captured earlier. Next: determine why the first hydrate still rebuilds all 1,224 ports despite warm cache adoption and whether Access snapshot time or materialize sort dominates the residual ~1.17 s.
- 2025-10-24 10:05 MT planning: Promote the WLLS snapshot/materialize regression card to In Progress and pursue four tracks: (1) assemble a cold vs. historical telemetry diff that isolates snapshot, materialize, and host-map counters for the first WLLS host; (2) audit the first-host pathways in `Modules/DeviceRepositoryModule.psm1` and `Modules/ParserPersistenceModule.psm1` for cache-adoption or materialization logic that still forces 1,224 candidate misses; (3) add targeted instrumentation if the existing telemetry cannot distinguish Access snapshot enumeration from in-process materialize costs; (4) rerun a focused WLLS cold pass plus the preserved warm regression to validate findings and feed the outcomes back into this plan and the task board.
- 2025-10-24 10:18 MT status: Telemetry diff complete. `Logs/IngestionMetrics/2025-10-24.json` (09:32 MT cold pass) shows WLLS-A01-AS-01 snapshot duration climbing to 859.4 ms (up from 482.9 ms on 2025-10-23 10:03 MT), materialize duration to 593.3 ms (was 339.7 ms), port-sort to 164.3 ms (was 74.4 ms), and host-map to 107.0 ms (was 67.3 ms). Template work grew to 13.8 ms (vs. 1.6 ms), pushing `SiteCacheFetchDurationMs` to 1,171.9 ms and `DatabaseWriteLatencyMs` to 1,790 ms (previously ~603 ms and 901 ms). Host-map candidate/match counts remain 1,224 rewrites / 0 matches, pointing to the same cache-miss behaviour; next step is the module audit/instrumentation outlined above.
- 2025-10-24 10:20 MT planning: Instrument the WLLS first-host path to split Access snapshot time from local materialization. Add timers/logging around `DeviceRepositoryModule\Get-InterfaceSiteCache` snapshot execution (ADO query vs. recordset materialize vs. port-sort/template stages) and capture adoption diagnostics in `Set-InterfaceSiteCacheHost` so we can confirm typed cache persistence before/after the hydrate. Mirror any new fields through `ParserPersistenceModule` telemetry to keep `DatabaseWriteBreakdown`/`InterfaceSiteCacheMetrics` aligned for the next cold run.
- 2025-10-24 11:07 MT status: Landed the first-host instrumentation. `DeviceRepositoryModule\Get-InterfaceSiteCache` now records `HydrationSnapshotRecordsetDurationMs` (ADO `GetRows` enumerate cost) alongside the existing snapshot/build/materialize timings, and `Set-InterfaceSiteCacheHost` emits `InterfaceSiteCacheHostPersisted` telemetry so typed host-map adoption can be traced per host/site. `ParserPersistenceModule` and `DeviceLogParserModule` propagate the new recordset timing through `InterfaceSyncTiming` and `DatabaseWriteBreakdown`, and unit coverage for both modules has been refreshed (`Invoke-Pester Modules/Tests/DeviceRepositoryModule.Tests.ps1`, `Modules/Tests/ParserPersistenceModule.Tests.ps1`). Next: rerun the focused WLLS cold pass plus the preserved-session warm regression to capture the new `SiteCacheRecordsetDurationMs`/host-persist telemetry, then update this plan and the task board with the fresh metrics.
- 2025-10-24 11:15 MT status: Focused cold replay (WLLS history cleared, pipeline rerun with `-ResetExtractedLogs`) captured the new telemetry for WLLS-A01-AS-01. `InterfaceSiteCacheMetrics` at 10:55:54 MT report `SnapshotDurationMs` 992.7 ms with only `RecordsetDurationMs` 19.9 ms, while local work dominates (`MaterializeDurationMs` 682.5 ms, `MaterializePortSortDurationMs` 185.3 ms, `HostMapDurationMs` 148.1 ms, `TemplateDurationMs` 16.4 ms, `HostMapCandidateMissingCount=1224`). Matching `DatabaseWriteBreakdown` events (`Logs/IngestionMetrics/2025-10-24.json` ~10:55:55 MT) log `SiteCacheFetchDurationMs` 1.385 s and `DatabaseWriteLatencyMs` 2.155 s before the warm pass flips to cache hits. `InterfaceSiteCacheHostPersisted` confirms typed host maps survive (`SharedStoreUpdated=True`, `PreviousHostMapWasTyped=True`). Follow-up: instrument the remainder of the snapshot block (the ~973 ms after recordset enumeration) to determine whether dictionary staging or snapshot cloning is absorbing the time before exploring additional Access-side optimisations.
- 2025-10-24 11:22 MT status: Preserved-session warm regression (`Tools\Invoke-WarmRunRegression.ps1 -VerboseParsing`) exported `WarmRunTelemetry-20251024-105636.json` with cold `InterfaceCallDurationMs` averaging 415.9 ms (p95 726.5 ms) and warm 323.8 ms (p95 413.4 ms), a 92.0 ms / 22.1% improvement. All 37 warm hosts pulled from cache (`WarmCacheProviderHitCount=37`, zero signature rewrites), confirming the new host-persist telemetry does not regress cache reuse. Next: feed the reduced improvement delta back into verification planning (prior run logged 43.6%) and use the additional snapshot instrumentation to chase down the remaining ~0.7-1.4 s cold hydrate penalty on WLLS-A01-AS-01.
- 2025-10-24 11:36 MT status: Added recordset projection instrumentation inside `Get-InterfacesForSite` (`RecordsetProjectDurationMs`) and surfaced it via `HydrationSnapshotProjectDurationMs` / `SiteCacheRecordsetProjectDurationMs` so the post-recordset portion of the snapshot block is captured end-to-end. Updated `InterfaceSiteCacheMetrics`, `DatabaseWriteBreakdown`, and unit suites (`DeviceRepositoryModule.Tests`, `ParserPersistenceModule.Tests`) now assert the new field; targeted Pester runs pass. Follow-up: rerun the focused WLLS cold pass plus the preserved warm regression to log the projection metric and quantify how much of the ~0.97 s gap falls inside the ADODB projection loop.
- 2025-10-24 11:25 MT status: Focused WLLS cold pass re-run (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs` after overwriting `Data/IngestionHistory/WLLS.json` with `[]`) captured the projection metric. `InterfaceSiteCacheMetrics` at 11:25:39 MT show WLLS-A01-AS-01 hydrating via Access with `HydrationDurationMs` 1,061.6 ms, `SnapshotDurationMs` 944.0 ms, `RecordsetDurationMs` 19.5 ms, `RecordsetProjectDurationMs` 196.6 ms, `MaterializeDurationMs` 649.9 ms (`MaterializePortSortDurationMs` 190.4 ms), `HostMapDurationMs` 114.1 ms, `TemplateDurationMs` 14.1 ms, and `HostMapCandidateMissingCount=1224`. The paired `DatabaseWriteBreakdown` entries log the same projection slices, confirming ~20 ms to enumerate ADO rows, ~200 ms to project them into typed cache entries, and the remaining ~650 ms spent in downstream materialize/port-sort work.
- 2025-10-24 11:27 MT status: Preserved-session warm regression (`Tools\Invoke-WarmRunRegression.ps1 -VerboseParsing`) exported `WarmRunTelemetry-20251024-112707.json` with cold `InterfaceCallDurationMs` averaging 406.7 ms (p95 683.6 ms, max 1,290.8 ms) and warm 329.8 ms (p95 423.7 ms, max 428.6 ms), yielding a 76.8 ms / 18.9% gain. All 37 warm hosts reported `Provider=Cache` with `HostMapSignatureMatchCount` equal to their port counts (e.g., WLLS-A01-AS-01 recorded 1,224 matches, zero rewrites), and the new recordset projection fields held at 0 ms during the cache hits. Next: reconcile the smaller warm-vs-cold delta against the earlier 22% run and continue probing the 650 ms materialize phase highlighted by the cold metrics.
- 2025-10-24 11:38 MT analysis: Parsed the 11:25:39 MT `InterfaceSiteCacheMetrics` event for WLLS-A01-AS-01 to quantify the 649.9 ms materialize slice. Breakdown: `MaterializePortSortDurationMs` 190.4 ms with `MaterializePortSortCacheMisses` 144 (hits 1,080), `MaterializeTemplateDurationMs` 131.4 ms, `MaterializeProjectionDurationMs` 52.2 ms, `MaterializeObjectDurationMs` 35.2 ms, plus `HostMapDurationMs` 114.1 ms and `TemplateLoadDurationMs` captured separately. The residual (~126 ms) sits in the per-row template hint application/lookup stopwatch that feeds `MaterializeTemplateDurationMs`. Follow-up: instrument the template resolution path to split lookup (dictionary/hint) vs. per-port application and capture port-sort cache miss causes so we can target the dominant materialize contributors.
- 2025-10-24 11:44 MT planning: Add finer-grained counters to `Get-InterfacesForSite` so `MaterializeTemplateDurationMs` divides into hint-cache lookup, template materialization, and per-port application (e.g., `MaterializeTemplateLookupDurationMs`, `MaterializeTemplateApplyDurationMs`, `MaterializeTemplateCacheMissCount`). Extend telemetry to surface port-sort cache ratios (`MaterializePortSortCacheMissRatio` or reuse count deltas) and template hint reuse counts. Once instrumentation lands, rerun the focused cold pass to confirm which bucket dominates the remaining ~126 ms and whether the 144 port-sort misses are isolated to specific ports or a broader cache invalidation.
- 2025-10-24 12:21 MT status: Instrumentation in place. Focused WLLS cold pass (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`, `Data/IngestionHistory/WLLS.json=[]`) now reports WLLS-A01-AS-01 with `MaterializeDurationMs` 781.876 ms comprising `MaterializePortSortDurationMs` 214.0 ms (`MaterializePortSortCacheHits` 1,080 / `Misses` 144, hit ratio 0.8824), `MaterializeTemplateDurationMs` 158.984 ms (`Lookup` 35.744 ms, `Apply` 56.846 ms, cache hits 1,216 / misses 8, hit ratio 0.9935), `MaterializeProjectionDurationMs` 72.637 ms, and `MaterializeObjectDurationMs` 40.755 ms while `HostMapDurationMs` climbed to 137.23 ms. Warm-run regression (`Tools/Invoke-WarmRunRegression.ps1 -VerboseParsing`) stays healthy with 37/37 cache hits and an 80.5 ms (19.9%) InterfaceCall improvement, confirming the extra counters do not disturb cache reuse. Next: drill into the 144 port-sort misses (capture representative port keys / cache states) and the 56.8 ms template-apply slice to determine whether per-port defaults or hint cloning can be tightened.
- 2025-10-24 13:45 MT status: Added port-sort and template apply instrumentation inside Get-InterfaceSiteCache (unique port counts, miss samples, template default vs matched counters) and propagated the fields through ParserPersistenceModule/DeviceLogParserModule with refreshed Pester coverage. Next: rerun the focused WLLS cold pass plus the preserved warm regression to populate the new metrics and review which ports/templates drive the misses and defaults.
- 2025-10-24 13:08 MT status: Focused WLLS cold replay with the new counters (`Tools/Invoke-StateTracePipeline.ps1 -SkipTests -VerboseParsing -ResetExtractedLogs`, `Data/IngestionHistory/WLLS.json=[]`) captured `InterfaceSyncTiming` at 13:06:39 MT showing `MaterializeDurationMs` 655.315 ms with `MaterializePortSortCacheHits` 1,080 / `Misses` 144 (11.8%) and miss samples covering Gi1/0/1–27 (`Logs/IngestionMetrics/2025-10-24.json`). Template apply cost registered `MaterializeTemplateApplyDurationMs` 59.574 ms with `TemplateCacheHits` 1,216 / `Misses` 8, all on the `flexible` template (first port pulled from lookup, rest from cache). The preserved-session regression (`Tools/Invoke-WarmRunRegression.ps1 -VerboseParsing`) immediately afterwards produced a cold pass at 13:07:27 MT with `MaterializeDurationMs` 403.064 ms, `PortSortMisses` trimmed to 48 (3.9%) and `TemplateApplyDurationMs` 42.785 ms (`TemplateCacheHits` 1,220 / `Misses` 4), while the warm pass at 13:07:51 MT stayed at 0 ms across materialize stages. Warm-run telemetry (`Logs/IngestionMetrics/WarmRunTelemetry-20251024-130713.json`) recorded cold `InterfaceCallDurationMs` 432.520 ms vs. warm 336.529 ms (95.991 ms / 22.19% gain) with `WarmCacheProviderHitCount=37`. Conclusion: the new telemetry highlights a persistent first-port cluster of port-sort misses and a small set of template cache misses even after cache reuse recovers.
- 2025-10-24 13:12 MT planning: Trace why Gi1/0/1–27 continue to miss the port-sort cache and why the first few ports still trigger template lookups despite typed cache persistence. Action items: audit the `MaterializePortSortCache` population in `DeviceRepositoryModule.psm1` (ensure typed cache entries retain `PortSortKey` during cold hydration and are restored before the next run), inspect whether sort keys reset when `InterfaceCacheEntry` is rehydrated, and confirm template hint records carry the cached signature for the first ports. Once hypotheses are in-hand, prototype either cache seeding or key reuse, then rerun the focused WLLS cold pass + preserved warm regression to validate drops in `MaterializePortSortCacheMissCount` and `MaterializeTemplateCacheMissCount`, updating this plan and the task board with the results.
- 2025-10-24 13:25 MT status: Port-sort cache audit confirms `InterfaceModule\Get-PortSortKey` (Modules/InterfaceModule.psm1:250-263) backs a process-wide concurrent dictionary while `Get-InterfacesForSite` recomputes the key for every cold hydration (Modules/DeviceRepositoryModule.psm1:4032-4045). The typed cache object persisted via `ConvertTo-InterfaceCacheEntryObject` (Modules/DeviceRepositoryModule.psm1:1205-1284) does not expose a `PortSort` property, so `Set-InterfaceSiteCacheHost` (Modules/DeviceRepositoryModule.psm1:2677-2708) stores rows without the previously calculated sort key. Result: each new process pays miss penalties for the first cohort of ports (Gi1/0/1–27 in today's focused run), and the miss count reflects ports whose uppercase identifier was not already present in the module-level cache. Subsequent hosts hit the warmed dictionary (`SiteCacheMaterializePortSortCacheMissCount=0`), so eliminating the first-host misses will require persisting or pre-seeding the `PortSort` value rather than further tuning telemetry.
- 2025-10-24 13:27 MT status: Template hint caching review shows `script:Get-TemplateHintCacheForVendor` (Modules/DeviceRepositoryModule.psm1:833-851) maintains a vendor+path dictionary, and the materialize loop only performs a lookup when a port lacks either color or config status (Modules/DeviceRepositoryModule.psm1:4065-4135). The WLLS cold pass executed 1,224 template applications with eight cache misses—the first occurrence of each template string before it was inserted into the hint cache—while all subsequent applications hit (`TemplateApplySamples` confirm the first port uses `HintSource=Lookup`, the rest `Cache`). The preserved-session cold pass (13:07:27 MT) still recorded four misses because we reset the ingestion history to empty arrays, forcing the helper to seed the cache inside a fresh session before warm reuse kicks in.
- 2025-10-24 13:52 MT status: Persisted port-sort keys on `InterfaceCacheEntry` and deferred `Get-PortSortKey` lookups to rewrite paths so cached rows reuse the stored sort value. Warm-run verification (`Tools/Invoke-StateTraceVerification.ps1 -SkipTests -VerboseParsing`) now reports cold `InterfaceCallDurationMs` 833.513 ms (p95 1,105.233 ms, max 1,186.221 ms) versus warm 739.521 ms (p95 1,000.819 ms, max 1,008.000 ms), a 93.992 ms / 11.28% gain with 37/37 cache providers = Cache. Warm `InterfaceSiteCacheMetrics` events for BOYO and WLLS log `MaterializePortSortCacheMisses=0` and `MaterializePortSortDurationMs=0`, confirming the cached keys suppress re-computation. Added a reuse fallback so cached host-map snapshots still surface `HostMapSignatureMatchCount` when the pass short-circuits without iterating rows. Follow-up: continue profiling the 56 ms template apply window and monitor the reduced warm improvement in case additional materialize stages need persistence.
- 2025-10-24 14:26 MT status: Implemented cached template reuse before the hint pipeline—if cached host entries supply `PortColor`/`ConfigStatus`, `HydrationMaterializeTemplateReuseCount` now tracks the short-circuit path and propagates through ParserPersistence/DeviceLogParser telemetry. The preserved-session warm regression still fell back to refresh hydrations (`SiteCacheProvider=Refresh`, signatures 0), leaving the reuse counter at 0/37. Next step: re-diagnose why warm passes miss cache hits (host map still rehydrates) before expecting the new reuse metric to climb.
