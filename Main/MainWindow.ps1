Add-Type -AssemblyName PresentationFramework

# 1) Paths
$scriptDir           = Split-Path -Parent $MyInvocation.MyCommand.Path
$parserScript        = Join-Path $scriptDir '.\NetworkReader.ps1'
$interfaceModulePath = Join-Path $scriptDir '..\Modules\InterfaceModule.psm1'
$interfacesViewXaml  = Join-Path $scriptDir '..\Views\InterfacesView.xaml'


# 2) Import Interfaces module
if (-not (Test-Path $interfaceModulePath)) {
    Write-Error "Cannot find InterfaceModule at $interfaceModulePath"
    exit 1
}
Import-Module $interfaceModulePath -Force

# 3) Load MainWindow.xaml
$xamlPath = Join-Path $scriptDir 'MainWindow.xaml'
if (-not (Test-Path $xamlPath)) {
    Write-Error "Cannot find MainWindow.xaml at $xamlPath"
    exit 1
}
$xamlContent = Get-Content $xamlPath -Raw
$reader      = New-Object System.Xml.XmlTextReader (New-Object System.IO.StringReader($xamlContent))
$window      = [Windows.Markup.XamlReader]::Load($reader)

Set-Variable -Name window -Value $window -Scope Global

# 4) Helpers

function Load-DeviceSummaries {
    # Retrieve a list of device hostnames from the parsed data directory
    $names = Get-DeviceSummaries

    # Build a metadata table keyed by hostname.  Each entry contains the
    # site code (first four characters of the hostname) along with location
    # details parsed from the SNMP location string.  The summary CSV
    # generated by the parser includes these fields.
    $global:DeviceMetadata = @{}
    foreach ($name in $names) {
        $summaryPath = Join-Path (Join-Path $scriptDir '..\ParsedData') "${name}_Summary.csv"
        if (Test-Path $summaryPath) {
            try {
                $rec = @(Import-Csv $summaryPath)[0]
                $meta = [PSCustomObject]@{
                    Site     = if ($rec.PSObject.Properties.Match('Site'))     { $rec.Site }     else { '' }
                    Building = if ($rec.PSObject.Properties.Match('Building')) { $rec.Building } else { '' }
                    Room     = if ($rec.PSObject.Properties.Match('Room'))     { $rec.Room }     else { '' }
                }
                $DeviceMetadata[$name] = $meta
            } catch {
                # Skip devices that fail to load metadata
            }
        }
    }

    # Populate the host dropdown initially with all names.  Filtering will be
    # applied through the Site/Building/Room dropdowns.  Use ItemsSource
    # assignment to refresh the list.
    $hostnameDD = $window.FindName('HostnameDropdown')
    $hostnameDD.ItemsSource = $names
    # When assigning a selection, choose the first element rather than
    # setting SelectedIndex.  Setting SelectedIndex on a bound control can
    # inadvertently try to update a variable named "Host" in the PowerShell
    # engine, which is read-only.  Using SelectedItem avoids touching the
    # underlying index property and prevents the error
    # "Cannot overwrite variable Host because it is read-only or constant."
    if ($names.Count -gt 0) {
        $hostnameDD.SelectedItem = $names[0]
    } else {
        $hostnameDD.SelectedItem = $null
    }

    # Populate the site dropdown with unique site codes.  Include an empty
    # option at the beginning to represent "all sites".  Sort the list for
    # consistent ordering.  Only devices that produced metadata contribute
    # entries.
    $siteDD = $window.FindName('SiteDropdown')
    $uniqueSites = @()
    if ($DeviceMetadata.Count -gt 0) {
        $uniqueSites = $DeviceMetadata.Values | ForEach-Object { $_.Site } | Where-Object { $_ -ne '' } | Sort-Object -Unique
    }
    $siteDD.ItemsSource = @('') + $uniqueSites
    # Default to the first (blank) site code using SelectedItem rather than SelectedIndex
    if ($siteDD.ItemsSource -and $siteDD.ItemsSource.Count -gt 0) {
        $siteDD.SelectedItem = $siteDD.ItemsSource[0]
    } else {
        $siteDD.SelectedItem = $null
    }

    # Clear the building and room dropdowns until a site is selected
    $buildingDD = $window.FindName('BuildingDropdown')
    $buildingDD.ItemsSource = @('')
    # Initialise Building selection
    if ($buildingDD.ItemsSource -and $buildingDD.ItemsSource.Count -gt 0) {
        $buildingDD.SelectedItem = $buildingDD.ItemsSource[0]
    } else {
        $buildingDD.SelectedItem = $null
    }
    $roomDD = $window.FindName('RoomDropdown')
    if ($roomDD) {
        $roomDD.ItemsSource = @('')
        # Select the blank entry via SelectedItem
        $roomDD.SelectedItem = ''
    }

    # Refresh the global interface list used by the search tab (if defined)
    if (Get-Command Rebuild-GlobalInterfaceList -ErrorAction SilentlyContinue) {
        Rebuild-GlobalInterfaceList
        # If the search grid has been initialized, refresh its ItemsSource to
        # show all interfaces for the newly loaded data.
        $searchHostCtrl = $window.FindName('SearchInterfacesHost')
        if ($searchHostCtrl -is [System.Windows.Controls.ContentControl]) {
            $searchView = $searchHostCtrl.Content
            if ($searchView) {
                $searchGrid = $searchView.FindName('SearchInterfacesGrid')
                if ($searchGrid) { $searchGrid.ItemsSource = $global:AllInterfaces }
            }
        }
    }
}

# Update the device dropdown based on the currently selected Site, Building and Room.
# This helper constructs a filtered list of hostnames from $DeviceMetadata.  It
# also repopulates the Building and Room dropdowns so the available values
# reflect the current site or building selection.  An empty selection for any
# dropdown represents "all".
function Update-DeviceFilter {
    if (-not $global:DeviceMetadata) { return }

    $siteSel = $window.FindName('SiteDropdown').SelectedItem
    $bldSel  = $window.FindName('BuildingDropdown').SelectedItem
    $roomSel = $window.FindName('RoomDropdown').SelectedItem

    # Filter hostnames based on selections
    $filteredNames = @()
    foreach ($name in $DeviceMetadata.Keys) {
        $meta = $DeviceMetadata[$name]
        if ($siteSel -and $siteSel -ne '' -and $meta.Site -ne $siteSel) { continue }
        if ($bldSel  -and $bldSel  -ne '' -and $meta.Building -ne $bldSel) { continue }
        if ($roomSel -and $roomSel -ne '' -and $meta.Room     -ne $roomSel) { continue }
        $filteredNames += $name
    }

    # Repopulate hostname dropdown
    $hostnameDD = $window.FindName('HostnameDropdown')
    $hostnameDD.ItemsSource = $filteredNames
    # Assign selection using SelectedItem to avoid modifying the read-only
    # PowerShell $Host variable
    if ($filteredNames.Count -gt 0) {
        $hostnameDD.SelectedItem = $filteredNames[0]
    } else {
        $hostnameDD.SelectedItem = $null
    }

    # Rebuild building dropdown options based on the selected site
    $availableBuildings = @()
    foreach ($name in $DeviceMetadata.Keys) {
        $meta = $DeviceMetadata[$name]
        if ($siteSel -and $siteSel -ne '' -and $meta.Site -ne $siteSel) { continue }
        if ($meta.Building -ne '') { $availableBuildings += $meta.Building }
    }
    $availableBuildings = $availableBuildings | Sort-Object -Unique
    $buildingDD = $window.FindName('BuildingDropdown')
    $buildingDD.ItemsSource = @('') + $availableBuildings
    # Preserve previously selected building if still valid
    if ($bldSel -and ($availableBuildings -contains $bldSel)) {
        $buildingDD.SelectedItem = $bldSel
    } else {
        # Default to blank when nothing matches
        if ($buildingDD.ItemsSource.Count -gt 0) {
            $buildingDD.SelectedItem = $buildingDD.ItemsSource[0]
        } else {
            $buildingDD.SelectedItem = $null
        }
        $bldSel = ''
    }

    # Rebuild room dropdown options based on selected site and building
    $availableRooms = @()
    foreach ($name in $DeviceMetadata.Keys) {
        $meta = $DeviceMetadata[$name]
        if ($siteSel -and $siteSel -ne '' -and $meta.Site -ne $siteSel) { continue }
        if ($bldSel  -and $bldSel  -ne '' -and $meta.Building -ne $bldSel) { continue }
        if ($meta.Room -ne '') { $availableRooms += $meta.Room }
    }
    $availableRooms = $availableRooms | Sort-Object -Unique
    $roomDD = $window.FindName('RoomDropdown')
    if ($roomDD) {
        $roomDD.ItemsSource = @('') + $availableRooms
        if ($roomSel -and ($availableRooms -contains $roomSel)) {
            $roomDD.SelectedItem = $roomSel
        } else {
            if ($roomDD.ItemsSource.Count -gt 0) {
                $roomDD.SelectedItem = $roomDD.ItemsSource[0]
            } else {
                $roomDD.SelectedItem = $null
            }
        }
    }

    # Refresh the search results grid to honour the updated
    # Site/Building/Room filters.  This ensures that the global
    # interface search respects the same filtering criteria as the
    # device selector.  Only call this function if it exists (it is
    # defined in the search tab injection logic).
    if (Get-Command Refresh-SearchGrid -ErrorAction SilentlyContinue) {
        Refresh-SearchGrid
    }
}

function Load-DeviceDetails {
    param($hostname)
    try {
        $base     = Join-Path (Join-Path $scriptDir '..\ParsedData') $hostname
        $summary  = @(Import-Csv "${base}_Summary.csv")[0]

        # Populate device detail controls housed within the Interfaces view.
        $interfacesView.FindName('HostnameBox').Text        = $summary.Hostname
        $interfacesView.FindName('MakeBox').Text            = $summary.Make
        $interfacesView.FindName('ModelBox').Text           = $summary.Model
        $interfacesView.FindName('UptimeBox').Text          = $summary.Uptime
        $interfacesView.FindName('PortCountBox').Text       = $summary.InterfaceCount
        $interfacesView.FindName('AuthDefaultVLANBox').Text = $summary.AuthDefaultVLAN
        # If location metadata was parsed, display the building and room values.
        $interfacesView.FindName('BuildingBox').Text = if ($summary.PSObject.Properties.Name -contains 'Building') { $summary.Building } else { '' }
        $interfacesView.FindName('RoomBox').Text     = if ($summary.PSObject.Properties.Name -contains 'Room')     { $summary.Room     } else { '' }

        $grid = $interfacesView.FindName('InterfacesGrid')
        $grid.ItemsSource = Get-InterfaceInfo -Hostname $hostname

        $combo = $interfacesView.FindName('ConfigOptionsDropdown')
        $combo.ItemsSource = Get-ConfigurationTemplates -Hostname $hostname
        # Choose the first template via SelectedItem instead of SelectedIndex.  Using
        # SelectedIndex can inadvertently modify the built-in $Host variable.
        if ($combo.Items.Count -gt 0) { $combo.SelectedItem = $combo.Items[0] }

    } catch {
        [System.Windows.MessageBox]::Show("Error loading ${hostname}:`n$($_.Exception.Message)")
    }
}

# 5) Inject InterfacesView
if (Test-Path $interfacesViewXaml) {
    $ifaceXaml     = Get-Content $interfacesViewXaml -Raw
    $ifaceReader   = New-Object System.Xml.XmlTextReader (New-Object System.IO.StringReader($ifaceXaml))
    $interfacesView= [Windows.Markup.XamlReader]::Load($ifaceReader)

    $interfacesHost = $window.FindName('InterfacesHost')
    if ($interfacesHost -is [System.Windows.Controls.ContentControl]) {
        $interfacesHost.Content = $interfacesView
    } else {
        Write-Warning "Could not find ContentControl 'InterfacesHost'"
    }

    $compareButton      = $interfacesView.FindName('CompareButton')
    $interfacesGrid     = $interfacesView.FindName('InterfacesGrid')
    $configureButton    = $interfacesView.FindName('ConfigureButton')
    $templateDropdown   = $interfacesView.FindName('ConfigOptionsDropdown')
    $filterBox          = $interfacesView.FindName('FilterBox')
    $clearBtn           = $interfacesView.FindName('ClearFilterButton')
    $copyDetailsButton  = $interfacesView.FindName('CopyDetailsButton')

    # 5b) Compare button
    if ($compareButton -and $interfacesGrid) {
        $compareButton.Add_Click({
            $selected = $interfacesGrid.ItemsSource | Where-Object { $_.IsSelected }
            if ($selected.Count -ne 2) {
                [System.Windows.MessageBox]::Show("Select exactly two interfaces to compare.")
                return
            }

            $int1 = $selected[0]
            $int2 = $selected[1]

            try {
                Compare-InterfaceConfigs `
                    -Switch1 $int1.Hostname -Interface1 $int1.Port `
                    -Switch2 $int2.Hostname -Interface2 $int2.Port
            } catch {
                [System.Windows.MessageBox]::Show("Compare failed:`n$($_.Exception.Message)")
            }
        })
    }

    # 5c) Configure button
    if ($configureButton -and $interfacesGrid -and $templateDropdown) {
        $configureButton.Add_Click({
            $selected = $interfacesGrid.ItemsSource | Where-Object { $_.IsSelected }
            if (-not $selected) {
                [System.Windows.MessageBox]::Show("No interfaces selected.")
                return
            }

            $template = $templateDropdown.SelectedItem
            if (-not $template) {
                [System.Windows.MessageBox]::Show("No template selected.")
                return
            }

            # Obtain hostname from the detail box in the Interfaces view
            $hostname = $interfacesView.FindName('HostnameBox').Text

            try {
                # Build hashtables containing any modified Name and VLAN values.  When the user
                # edits the Name or VLAN columns in the grid, the underlying objects are
                # updated.  Capture those values so they can be passed along to the
                # configuration generator.  Keys are the port identifiers, values are the
                # overridden names/VLANs.
                $namesMap = @{}
                $vlansMap = @{}
                foreach ($int in $selected) {
                    if ($int.Name -and $int.Name -ne '') { $namesMap[$int.Port] = $int.Name }
                    if ($int.VLAN -and $int.VLAN -ne '') { $vlansMap[$int.Port] = $int.VLAN }
                }
                $ports = $selected | ForEach-Object { $_.Port }
                $lines = Get-InterfaceConfiguration -Hostname $hostname -Interfaces $ports -TemplateName $template -NewNames $namesMap -NewVlans $vlansMap
                Set-Clipboard -Value ($lines -join "`r`n")
                [System.Windows.MessageBox]::Show(($lines -join "`n"), "Generated Config")
            } catch {
                [System.Windows.MessageBox]::Show("Failed to build config:`n$($_.Exception.Message)")
            }
        })
    }

    # 5d) Filter logic
    if ($clearBtn -and $filterBox -and $interfacesGrid) {
        $clearBtn.Add_Click({
            $filterBox.Text = ""
            $filterBox.Focus()
        })
    }

    if ($filterBox -and $interfacesGrid) {
        $filterBox.Add_TextChanged({
            $text = $filterBox.Text.ToLower()
            $view = [System.Windows.Data.CollectionViewSource]::GetDefaultView($interfacesGrid.ItemsSource)
            if ($null -eq $view) { return }

            $view.Filter = {
                param ($item)
                return (
                    ($item.Port       -as [string]).ToLower().Contains($text) -or
                    ($item.Name       -as [string]).ToLower().Contains($text) -or
                    ($item.Status     -as [string]).ToLower().Contains($text) -or
                    ($item.VLAN       -as [string]).ToLower().Contains($text) -or
                    ($item.AuthState  -as [string]).ToLower().Contains($text)
                )
            }
            $view.Refresh()
        })
    }

    # 5e) Copy Details button
    if ($copyDetailsButton -and $interfacesGrid) {
        $copyDetailsButton.Add_Click({
            $selected = $interfacesGrid.ItemsSource | Where-Object { $_.IsSelected }
            if (-not $selected -or $selected.Count -eq 0) {
                [System.Windows.MessageBox]::Show("No interfaces selected.")
                return
            }

            # Obtain hostname from the detail box in the Interfaces view
            $hostname = $interfacesView.FindName('HostnameBox').Text
            $summaryPath = Join-Path (Join-Path $scriptDir '..\ParsedData') "${hostname}_Summary.csv"

            $authBlock = ""
            if (Test-Path $summaryPath) {
                $summary = @(Import-Csv $summaryPath)[0]
                if ($summary.AuthBlock -and $summary.AuthBlock.Trim() -ne "") {
                    $authBlock = $summary.AuthBlock.Trim()
                }
            }

            $header = @("Hostname: $hostname","------------------------------")
            if ($authBlock -ne "") {
                $header += @("Auth Block:", $authBlock, "","------------------------------")
            } else {
                $header += ""
            }

            $output = foreach ($int in $selected) {
                $lines = @(
                    "Port:        $($int.Port)"
                    "Name:        $($int.Name)"
                    "Status:      $($int.Status)"
                    "VLAN:        $($int.VLAN)"
                    "Duplex:      $($int.Duplex)"
                    "Speed:       $($int.Speed)"
                    "Type:        $($int.Type)"
                    "LearnedMACs: $($int.LearnedMACs)"
                    "AuthState:   $($int.AuthState)"
                    "AuthMode:    $($int.AuthMode)"
                    "Client MAC:  $($int.AuthClientMAC)"
                    "Config:"
                    "$($int.ToolTip)"
                    "------------------------------"
                )
                $lines -join "`r`n"
            }

            $final = $header + $output
            Set-Clipboard -Value ($final -join "`r`n")

            [System.Windows.MessageBox]::Show("Copied $($selected.Count) interface(s) with auth block to clipboard.")
        })
    }
    
} else {
    Write-Warning "Missing InterfacesView.xaml at $interfacesViewXaml"
}

# 5c) Inject SpanView
$spanViewXamlPath = Join-Path $scriptDir '..\Views\SpanView.xaml'
if (Test-Path $spanViewXamlPath) {
    $spanXaml   = Get-Content $spanViewXamlPath -Raw
    $spanReader = New-Object System.Xml.XmlTextReader (New-Object System.IO.StringReader($spanXaml))
    $spanView   = [Windows.Markup.XamlReader]::Load($spanReader)
    $spanHost   = $window.FindName('SpanHost')
    if ($spanHost -is [System.Windows.Controls.ContentControl]) {
        $spanHost.Content = $spanView
    } else {
        Write-Warning "Could not find ContentControl 'SpanHost'"
    }
    # Access controls
    $spanGrid     = $spanView.FindName('SpanGrid')
    $vlanDropdown = $spanView.FindName('VlanDropdown')
    $spanRefresh  = $spanView.FindName('RefreshSpanButton')

    # Helper to load spanning tree data for the currently selected device.  It
    # populates the grid and VLAN dropdown.  If no data exists for the
    # device, the grid will be cleared and the dropdown reset.
    function Load-SpanInfo {
        param([string]$Hostname)
        if (-not $spanGrid) { return }
        # If no hostname provided, clear the grid and dropdown
        if (-not $Hostname) {
            $spanGrid.ItemsSource = @()
            if ($vlanDropdown) {
                $vlanDropdown.ItemsSource = @('')
                # When clearing the dropdown use SelectedItem instead of SelectedIndex. Using
                # SelectedIndex can inadvertently attempt to set the built‑in $Host variable
                # which is read‑only and will throw an exception.  Selecting the first item
                # via SelectedItem avoids this pitfall.
                if ($vlanDropdown.ItemsSource.Count -gt 0) {
                    $vlanDropdown.SelectedItem = $vlanDropdown.ItemsSource[0]
                } else {
                    $vlanDropdown.SelectedItem = $null
                }
            }
            return
        }
        # Retrieve spanning tree data for the hostname.  Import failures
        # return an empty collection.
        try {
            $data = Get-SpanningTreeInfo -Hostname $Hostname
        } catch {
            $data = @()
        }
        $spanGrid.ItemsSource = $data
        if ($vlanDropdown) {
            $instances = ($data | ForEach-Object { $_.VLAN }) | Sort-Object -Unique
            $vlanDropdown.ItemsSource = @('') + $instances
            # Select the first item safely using SelectedItem.  Avoid SelectedIndex to
            # prevent conflicts with the PowerShell $Host variable.
            if ($vlanDropdown.ItemsSource -and $vlanDropdown.ItemsSource.Count -gt 0) {
                $vlanDropdown.SelectedItem = $vlanDropdown.ItemsSource[0]
            } else {
                $vlanDropdown.SelectedItem = $null
            }
        }
    }
    # Handler for VLAN dropdown filtering
    if ($vlanDropdown) {
        $vlanDropdown.Add_SelectionChanged({
            $sel = $vlanDropdown.SelectedItem
            if (-not $spanGrid) { return }
            # Retrieve the currently selected hostname.  Use a local variable
            # name other than $host to avoid conflict with the built‑in $Host
            # variable (PowerShell is case‑insensitive, so $host would
            # reference the same read‑only Host object).
            $selectedHost = $window.FindName('HostnameDropdown').SelectedItem
            if (-not $selectedHost) { return }
            # Reload data for the host
            $all = Get-SpanningTreeInfo -Hostname $selectedHost
            if (-not $sel -or $sel -eq '') {
                $spanGrid.ItemsSource = $all
            } else {
                $spanGrid.ItemsSource = $all | Where-Object { $_.VLAN -eq $sel }
            }
        })
    }
    # Refresh button to reparse logs for spanning tree info.  This triggers
    # log parsing like the main refresh button and then reloads the span info.
    if ($spanRefresh) {
        $spanRefresh.Add_Click({
            # Run the parser script to update parsed data (honouring archive flags).  Reuse
            # environment variables from the main refresh button.
            & "$parserScript"
            # Reload summaries and span info for selected host.
            Load-DeviceSummaries
            Update-DeviceFilter
            $currentHost = $window.FindName('HostnameDropdown').SelectedItem
            if ($currentHost) { Load-SpanInfo $currentHost }
        })
    }
    # Load span info when host selection changes.  We'll add this in the
    # existing hostname dropdown event after it's defined.
} else {
    Write-Warning "Missing SpanView.xaml at $spanViewXamlPath"
}

# 5a) Inject SearchInterfacesView
$searchViewXamlPath = Join-Path $scriptDir '..\Views\SearchInterfacesView.xaml'
if (Test-Path $searchViewXamlPath) {
    $searchXaml      = Get-Content $searchViewXamlPath -Raw
    $searchReader    = New-Object System.Xml.XmlTextReader (New-Object System.IO.StringReader($searchXaml))
    $searchView      = [Windows.Markup.XamlReader]::Load($searchReader)

    $searchHost      = $window.FindName('SearchInterfacesHost')
    if ($searchHost -is [System.Windows.Controls.ContentControl]) {
        $searchHost.Content = $searchView
    } else {
        Write-Warning "Could not find ContentControl 'SearchInterfacesHost'"
    }

    # Access key controls from the search view
    $searchBox        = $searchView.FindName('SearchBox')
    $searchClearBtn   = $searchView.FindName('SearchClearButton')
    $searchGrid       = $searchView.FindName('SearchInterfacesGrid')

    # Build a global interface list for searching.  This will be refreshed
    # whenever Load-DeviceSummaries is invoked (i.e. after log parsing).  Use
    # a script-level variable so the collection persists between searches.
    $global:AllInterfaces = @()
    function Rebuild-GlobalInterfaceList {
        $list = @()
        # Determine the parsed data directory relative to this script
        $parsedDir = Join-Path $scriptDir '..\ParsedData'
        if (-not (Test-Path $parsedDir)) {
            $global:AllInterfaces = @()
            return
        }
        # Enumerate all interface CSVs, including those with dated suffixes
        $files = Get-ChildItem -Path $parsedDir -Filter '*_Interfaces_Combined*.csv' -File
        foreach ($f in $files) {
            # Extract hostname by splitting on the first underscore
            $baseName = [System.IO.Path]::GetFileNameWithoutExtension($f.Name)
            $parts = $baseName -split '_'
            $hostName = $parts[0]
            # Load summary data for this host to obtain site/building/room
            $summaryPath = Join-Path $parsedDir "$hostName`_Summary.csv"
            $site = ''; $building=''; $room=''
            if (Test-Path $summaryPath) {
                try {
                    $summary = @(Import-Csv $summaryPath)[0]
                    # Cast metadata to strings to ensure comparisons work as expected when
                    # filtering.  Without casting, numeric values may not match string
                    # selections in the Site/Building/Room dropdowns.  When fields are
                    # missing, default to empty string.
                    if ($summary.PSObject.Properties.Name -contains 'Site')     { $site     = [string]$summary.Site }
                    if ($summary.PSObject.Properties.Name -contains 'Building') { $building = [string]$summary.Building }
                    if ($summary.PSObject.Properties.Name -contains 'Room')     { $room     = [string]$summary.Room }
                } catch {}
            }
            try {
                $csvData = Import-Csv $f.FullName
                foreach ($row in $csvData) {
                    # Clone the row and inject the hostname and location properties
                    $obj = [PSCustomObject]@{}
                    foreach ($prop in $row.PSObject.Properties) {
                        $obj | Add-Member -NotePropertyName $prop.Name -NotePropertyValue $prop.Value -Force
                    }
                    $obj | Add-Member -NotePropertyName Hostname -NotePropertyValue $hostName -Force
                    # Ensure that Site/Building/Room values attached to each row are
                    # strings.  Without forcing the type here, the values may remain
                    # integers when loaded from CSV, preventing proper comparison
                    # against the dropdown selections (which are strings).  Casting
                    # here ensures the filter logic in Filter-SearchResults operates
                    # correctly.
                    $obj | Add-Member -NotePropertyName Site      -NotePropertyValue ([string]$site)      -Force
                    $obj | Add-Member -NotePropertyName Building  -NotePropertyValue ([string]$building)  -Force
                    $obj | Add-Member -NotePropertyName Room      -NotePropertyValue ([string]$room)      -Force
                    $list += $obj
                }
            } catch {
                # Skip files that cannot be imported
            }
        }
        $global:AllInterfaces = $list
    }
    # Rebuild interface list initially
    Rebuild-GlobalInterfaceList

    # Filter the global interface list based on the search term.  The term
    # matches across several fields (port, name, learned MACs and auth client
    # MAC).  The search is case-insensitive.
    function Filter-SearchResults {
        param([string]$Term)
        $t = $Term.ToLower()
        if ([string]::IsNullOrWhiteSpace($t)) {
            return $global:AllInterfaces
        }
        # Retrieve the currently selected Site, Building and Room from the
        # dropdowns on the main window.  An empty selection represents
        # "All" so we do not apply that filter.  Because this helper is
        # defined within the scope of the window, we can access $window
        # directly.
        $siteSel = $window.FindName('SiteDropdown').SelectedItem
        $bldSel  = $window.FindName('BuildingDropdown').SelectedItem
        $roomSel = $window.FindName('RoomDropdown').SelectedItem

        return $global:AllInterfaces | Where-Object {
            $row = $_
            # Cast row metadata to strings to ensure comparisons succeed.  When
            # the CSV values are numeric, the cast prevents mismatches when
            # comparing against the dropdown selections (which are strings).
            $rowSite     = [string]$row.Site
            $rowBuilding = [string]$row.Building
            $rowRoom     = [string]$row.Room
            # Apply site/building/room filtering first.  Skip rows that
            # don't match the selected values.  If the selection is blank
            # ("All"), then all values are permitted for that field.
            if ($siteSel -and $siteSel -ne '' -and ($rowSite -ne $siteSel)) { return $false }
            if ($bldSel  -and $bldSel  -ne '' -and ($rowBuilding -ne $bldSel)) { return $false }
            if ($roomSel -and $roomSel -ne '' -and ($rowRoom     -ne $roomSel)) { return $false }
            # Next apply the textual search filter.  Match against port,
            # name, learned MACs and auth client MAC.  If no search term
            # was provided, everything passes.
            return (
                ($row.Port        -as [string]).ToLower().Contains($t) -or
                ($row.Name        -as [string]).ToLower().Contains($t) -or
                ($row.LearnedMACs -as [string]).ToLower().Contains($t) -or
                ($row.AuthClientMAC -as [string]).ToLower().Contains($t)
            )
        }
    }

    # Event handler for search box
    if ($searchBox) {
        $searchBox.Add_TextChanged({
            # When the search term changes, refresh the search grid so
            # results reflect both the textual filter and the current
            # Site/Building/Room selections.
            if (Get-Command Refresh-SearchGrid -ErrorAction SilentlyContinue) {
                Refresh-SearchGrid
            } else {
                # Fallback if the helper isn't defined yet
                $term = $searchBox.Text
                $results = Filter-SearchResults -Term $term
                $searchGrid.ItemsSource = $results
            }
        })
    }
    # Event handler for clear button
    if ($searchClearBtn) {
        $searchClearBtn.Add_Click({
            $searchBox.Text = ''
            $searchBox.Focus()
            if (Get-Command Refresh-SearchGrid -ErrorAction SilentlyContinue) {
                Refresh-SearchGrid
            }
        })
    }
    # Populate the initial empty table
    if ($searchGrid) {
        $searchGrid.ItemsSource = $global:AllInterfaces
    }

    # Helper to refresh the search grid when site/building/room
    # selections change or when the search term updates.  This pulls
    # the current search term from the search box and re-filters
    # $global:AllInterfaces accordingly.
    function Refresh-SearchGrid {
        # Access controls within the search view
        $searchHostCtrl = $window.FindName('SearchInterfacesHost')
        if (-not $searchHostCtrl) { return }
        $view = $searchHostCtrl.Content
        if (-not $view) { return }
        $gridCtrl  = $view.FindName('SearchInterfacesGrid')
        $boxCtrl   = $view.FindName('SearchBox')
        if (-not $gridCtrl -or -not $boxCtrl) { return }
        $term = $boxCtrl.Text
        $gridCtrl.ItemsSource = Filter-SearchResults -Term $term
    }
} else {
    Write-Warning "Missing SearchInterfacesView.xaml at $searchViewXamlPath"
}

# 6) Hook up main window controls
$refreshBtn = $window.FindName('RefreshButton')
if ($refreshBtn) {
    $refreshBtn.Add_Click({
        # Capture archive inclusion settings from the checkboxes.  Blank/unset
        # values indicate that archives should not be processed.  Use strings
        # instead of booleans so the downstream script can detect them via
        # $env variables.
        $includeArchiveCB = $window.FindName('IncludeArchiveCheckbox')
        $includeHistoricalCB = $window.FindName('IncludeHistoricalCheckbox')
        if ($includeArchiveCB) {
            if ($includeArchiveCB.IsChecked) { $env:IncludeArchive = 'true' } else { $env:IncludeArchive = '' }
        }
        if ($includeHistoricalCB) {
            if ($includeHistoricalCB.IsChecked) { $env:IncludeHistorical = 'true' } else { $env:IncludeHistorical = '' }
        }
        # Run the parser script.  It will inspect the environment variables
        # defined above to determine whether to include archive data.  After
        # completion, reload the device summaries and refresh the filters.
        & "$parserScript"
        Load-DeviceSummaries
        Update-DeviceFilter
    })
}

$hostnameDropdown = $window.FindName('HostnameDropdown')
if ($hostnameDropdown) {
    $hostnameDropdown.Add_SelectionChanged({
        $sel = $hostnameDropdown.SelectedItem
        if ($sel) {
            Load-DeviceDetails $sel
            # If the Span tab is loaded and helper exists, load span info
            if (Get-Command Load-SpanInfo -ErrorAction SilentlyContinue) {
                Load-SpanInfo $sel
            }
        } else {
            # Clear span grid when nothing selected
            if (Get-Command Load-SpanInfo -ErrorAction SilentlyContinue) {
                Load-SpanInfo ''
            }
        }
    })
}

# Hook site/building/room dropdowns to update filtering
$siteDropdown = $window.FindName('SiteDropdown')
if ($siteDropdown) {
    $siteDropdown.Add_SelectionChanged({
        Update-DeviceFilter
    })
}

$buildingDropdown = $window.FindName('BuildingDropdown')
if ($buildingDropdown) {
    $buildingDropdown.Add_SelectionChanged({
        Update-DeviceFilter
    })
}

$roomDropdown = $window.FindName('RoomDropdown')
if ($roomDropdown) {
    $roomDropdown.Add_SelectionChanged({
        Update-DeviceFilter
    })
}

# Hook up ShowCisco and ShowBrocade buttons to copy show command sequences
$showCiscoBtn   = $window.FindName('ShowCiscoButton')
$showBrocadeBtn = $window.FindName('ShowBrocadeButton')
$brocadeOSDD    = $window.FindName('BrocadeOSDropdown')

if ($showCiscoBtn) {
    $showCiscoBtn.Add_Click({
        # Build a list of Cisco show commands.  Prepend a command to
        # disable pagination so the output is not interrupted.  Adjust
        # commands as needed to collect all relevant information.
        $cmds = @(
            'terminal length 0',
            'show version',
            'show running-config',
            'show interfaces status',
            'show mac address-table',
            'show spanning-tree',
            'show lldp neighbors',
            'show cdp neighbors',
            'show dot1x all',
            'show access-lists'
        )
        $text = $cmds -join "`r`n"
        Set-Clipboard -Value $text
        [System.Windows.MessageBox]::Show("Cisco show commands copied to clipboard.")
    })
}

if ($showBrocadeBtn) {
    $showBrocadeBtn.Add_Click({
        # Determine the selected OS version from dropdown; default to first item
        $osVersion = 'v8.0.30'
        if ($brocadeOSDD -and $brocadeOSDD.SelectedItem) {
            $osVersion = $brocadeOSDD.SelectedItem.Content
        }
        # Build common Brocade commands.  Use skip-page to disable paging.
        $cmds = @(
            'skip-page',
            'show version',
            'show config',
            'show interfaces brief',
            'show mac-address',
            'show spanning-tree',
            'show lldp neighbors',
            'show cdp neighbors',
            'show dot1x sessions all',
            'show mac-authentication sessions all',
            'show access-lists'
        )
        # Some OS versions might require variant commands.  For example, version
        # 8.0.95 (jufi) may include stack information.  Add extra commands
        # when that version is selected.
        if ($osVersion -eq 'v8.0.95') {
            $cmds += 'show stacking',
                     'show vlan'
        }
        $text = $cmds -join "`r`n"
        Set-Clipboard -Value $text
        [System.Windows.MessageBox]::Show("Brocade show commands for $osVersion copied to clipboard.")
    })
}

# 7) Load initial state after window shows
$window.Add_Loaded({
    try {
        & "$parserScript"
        Load-DeviceSummaries
        if ($window.FindName('HostnameDropdown').Items.Count -gt 0) {
            $first = $window.FindName('HostnameDropdown').Items[0]
            Load-DeviceDetails $first
            if (Get-Command Load-SpanInfo -ErrorAction SilentlyContinue) {
                Load-SpanInfo $first
            }
        }
    } catch {
        [System.Windows.MessageBox]::Show("Log parsing failed:`n$($_.Exception.Message)", "Error")
    }
})


if ($window.FindName('HostnameDropdown').Items.Count -gt 0) {
    $first = $window.FindName('HostnameDropdown').Items[0]
    Load-DeviceDetails $first
    if (Get-Command Load-SpanInfo -ErrorAction SilentlyContinue) {
        Load-SpanInfo $first
    }
}

# 8) Show window
$window.ShowDialog() | Out-Null

# 9) Cleanup
$parsedDir = Join-Path $scriptDir '..\ParsedData'
if (Test-Path $parsedDir) {
    try { Get-ChildItem $parsedDir -Recurse | Remove-Item -Force -Recurse }
    catch { Write-Warning "Failed to clear ParsedData: $_" }
}